"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/services/chatRealTime.ts":
/*!**************************************!*\
  !*** ./src/services/chatRealTime.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: function() { return /* binding */ chatService; }\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n\n\nclass ChatService {\n    connect() {\n        // Si ya tenemos una promesa de conexión en curso, la retornamos\n        if (this.connectPromise) {\n            return this.connectPromise;\n        }\n        this.connectPromise = new Promise((resolve)=>{\n            var _this_socket;\n            if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n                resolve();\n                return;\n            }\n            if (this.isConnecting) {\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(this.baseUrl, {\n                withCredentials: true,\n                transports: [\n                    \"polling\",\n                    \"websocket\"\n                ],\n                timeout: 20000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                reconnectionDelay: 2000,\n                reconnectionDelayMax: 10000,\n                forceNew: false,\n                autoConnect: true,\n                upgrade: true,\n                rememberUpgrade: false\n            });\n            this.socket.on(\"connect\", ()=>{\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(true));\n                resolve();\n            });\n            this.socket.on(\"connect_error\", (error)=>{\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Solo intentar reconectar automáticamente en errores de red\n                if (error.message && !error.message.includes(\"xhr poll error\")) {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            this.socket.on(\"disconnect\", (reason)=>{\n                console.log(\"\\uD83D\\uDD0C Socket.IO disconnected:\", reason);\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Auto-reconectar solo si no fue una desconexión intencional\n                if (reason !== \"io client disconnect\" && reason !== \"io server disconnect\") {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            // Timeout más generoso para permitir la conexión\n            setTimeout(()=>{\n                var _this_socket;\n                this.isConnecting = false;\n                if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                    console.log(\"⚠️ Socket.IO connection timeout, falling back to HTTP\");\n                    this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                }\n                resolve();\n            }, 15000);\n            this.socket.on(\"new_message\", (message)=>{\n                console.log(\"\\uD83D\\uDCE8 New message received:\", message);\n                // Mostrar notificación de nuevo mensaje\n                this.showNotification(message);\n                this.messageCallbacks.forEach((callback)=>callback(message));\n            });\n            this.socket.on(\"message_sent\", (message)=>{\n                console.log(\"✅ Message sent confirmation:\", message);\n            });\n            this.socket.on(\"user_status\", (data)=>{\n                console.log(\"\\uD83D\\uDC64 User status change:\", data);\n                this.userStatusCallbacks.forEach((callback)=>callback(data.user_id, data.status));\n            });\n            this.socket.on(\"user_typing\", (data)=>{\n                console.log(\"⌨️ User typing:\", data);\n                this.typingCallbacks.forEach((callback)=>callback(data.user_id, data.is_typing));\n            });\n            this.socket.on(\"unread_message\", (data)=>{\n                console.log(\"\\uD83D\\uDD14 Unread message notification:\", data);\n                this.unreadMessageCallbacks.forEach((callback)=>callback(data));\n            });\n            this.socket.on(\"message_error\", (error)=>{\n                console.error(\"❌ Message error:\", error.error);\n            });\n        });\n        return this.connectPromise;\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n        setTimeout(()=>{\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                this.connectPromise = null; // Reset promise\n                this.connect();\n            }\n        }, delay);\n    }\n    showNotification(message) {\n        // Solo mostrar notificación si el usuario no está en la página del chat\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            if (document.hidden) {\n                new Notification(\"Nuevo mensaje de \".concat(message.sender_name), {\n                    body: message.message,\n                    icon: \"/favicon.ico\",\n                    tag: \"chat-message\"\n                });\n            }\n        }\n    }\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectPromise = null; // Reset promise\n        this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n    }\n    isSocketConnected() {\n        var _this_socket;\n        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;\n    }\n    sendMessage(receiverId, message) {\n        var _this_socket;\n        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n            this.sendMessageHttp(receiverId, message).catch((error)=>{\n                console.error(\"Error enviando mensaje por HTTP:\", error);\n            });\n            return;\n        }\n        this.socket.emit(\"send_message\", {\n            receiver_id: receiverId,\n            message: message\n        });\n    }\n    sendTypingIndicator(receiverId, isTyping) {\n        var _this_socket;\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            this.socket.emit(\"typing\", {\n                receiver_id: receiverId,\n                is_typing: isTyping\n            });\n        }\n    }\n    startTyping(receiverId) {\n        this.sendTypingIndicator(receiverId, true);\n        // Limpiar timer anterior si existe\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n        }\n        // Enviar \"stop typing\" después de 3 segundos\n        this.typingTimer = setTimeout(()=>{\n            this.sendTypingIndicator(receiverId, false);\n        }, 3000);\n    }\n    stopTyping(receiverId) {\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n            this.typingTimer = null;\n        }\n        this.sendTypingIndicator(receiverId, false);\n    }\n    async sendMessageHttp(receiverId, message) {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/send-message\", {\n                receiver_id: receiverId,\n                message: message\n            });\n            const messageData = {\n                id: response.data.id.toString(),\n                sender_id: response.data.sender_id.toString(),\n                receiver_id: response.data.receiver_id.toString(),\n                sender_name: \"T\\xfa\",\n                message: response.data.message,\n                timestamp: response.data.timestamp,\n                is_mine: true\n            };\n            // Notificar a los callbacks\n            this.messageCallbacks.forEach((callback)=>callback(messageData));\n            return messageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n    onMessage(callback) {\n        this.messageCallbacks.push(callback);\n        return ()=>{\n            const index = this.messageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.messageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUserStatusChange(callback) {\n        this.userStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.userStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.userStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onConnectionStatus(callback) {\n        this.connectionStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.connectionStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.connectionStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onTyping(callback) {\n        this.typingCallbacks.push(callback);\n        return ()=>{\n            const index = this.typingCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.typingCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUnreadMessage(callback) {\n        this.unreadMessageCallbacks.push(callback);\n        return ()=>{\n            const index = this.unreadMessageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.unreadMessageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    requestNotificationPermission() {\n        if (\"Notification\" in window && Notification.permission === \"default\") {\n            Notification.requestPermission();\n        }\n    }\n    async getMessages(receiverId) {\n        try {\n            // Usar la nueva ruta que maneja UUIDs\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-messages-uuid/\".concat(receiverId));\n            return response.data.messages || [];\n        } catch (error) {\n            throw error;\n        }\n    }\n    async getUsers() {\n        try {\n            var _data_doctors;\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-chat-doctors\");\n            const data = response.data;\n            return ((_data_doctors = data.doctors) === null || _data_doctors === void 0 ? void 0 : _data_doctors.map((doctor)=>({\n                    id: doctor.id.toString(),\n                    supabase_id: doctor.supabase_id,\n                    name: \"\".concat(doctor.firstName, \" \").concat(doctor.lastName1),\n                    email: doctor.email,\n                    specialty: doctor.speciality,\n                    status: \"offline\"\n                }))) || [];\n        } catch (error) {\n            return [\n                {\n                    id: \"1\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Juan P\\xe9rez\",\n                    email: \"juan.perez@hospital.com\",\n                    specialty: \"Cardiolog\\xeda\",\n                    status: \"online\"\n                },\n                {\n                    id: \"2\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dra. Mar\\xeda Gonz\\xe1lez\",\n                    email: \"maria.gonzalez@hospital.com\",\n                    specialty: \"Neurolog\\xeda\",\n                    status: \"offline\"\n                },\n                {\n                    id: \"3\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Carlos L\\xf3pez\",\n                    email: \"carlos.lopez@hospital.com\",\n                    specialty: \"Pediatr\\xeda\",\n                    status: \"offline\"\n                }\n            ];\n        }\n    }\n    async getUnreadCounts() {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-unread-counts\");\n            const data = response.data;\n            return data.unread_counts || {};\n        } catch (error) {\n            return {};\n        }\n    }\n    constructor(){\n        this.socket = null;\n        this.baseUrl = \"http://localhost:5000\" || 0;\n        this.messageCallbacks = [];\n        this.userStatusCallbacks = [];\n        this.connectionStatusCallbacks = [];\n        this.typingCallbacks = [];\n        this.unreadMessageCallbacks = [];\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.isConnecting = false;\n        this.typingTimer = null;\n        this.connectPromise = null;\n    }\n}\nconst chatService = new ChatService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0UmVhbFRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ2xCO0FBeUM1QixNQUFNRTtJQWNKQyxVQUF5QjtRQUN2QixnRUFBZ0U7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzdCO1lBQUosS0FBSSxtQkFBSSxDQUFDQyxNQUFNLGNBQVgsZ0RBQWFDLFNBQVMsRUFBRTtnQkFDMUJGO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ0csWUFBWSxFQUFFO2dCQUNyQkg7Z0JBQ0E7WUFDRjtZQUVBLElBQUksQ0FBQ0csWUFBWSxHQUFHO1lBRXBCLElBQUksQ0FBQ0YsTUFBTSxHQUFHUCxvREFBRUEsQ0FBQyxJQUFJLENBQUNVLE9BQU8sRUFBRTtnQkFDN0JDLGlCQUFpQjtnQkFDakJDLFlBQVk7b0JBQUM7b0JBQVc7aUJBQVk7Z0JBQ3BDQyxTQUFTO2dCQUNUQyxjQUFjO2dCQUNkQyxzQkFBc0I7Z0JBQ3RCQyxtQkFBbUI7Z0JBQ25CQyxzQkFBc0I7Z0JBQ3RCQyxVQUFVO2dCQUNWQyxhQUFhO2dCQUNiQyxTQUFTO2dCQUNUQyxpQkFBaUI7WUFDbkI7WUFFQSxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsRUFBRSxDQUFDLFdBQVc7Z0JBQ3hCLElBQUksQ0FBQ2IsWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNjLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLHlCQUF5QixDQUFDQyxPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7Z0JBQzVEcEI7WUFDRjtZQUVBLElBQUksQ0FBQ0MsTUFBTSxDQUFDZSxFQUFFLENBQUMsaUJBQWlCLENBQUNLO2dCQUMvQixJQUFJLENBQUNsQixZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FB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QUNQQyxXQUFXO29CQUNYL0QsUUFBUTtnQkFDVjthQUNEO1FBQ0g7SUFDRjtJQUVBLE1BQU1tRSxrQkFBeUQ7UUFDN0QsSUFBSTtZQUNGLE1BQU1uQyxXQUFXLE1BQU12RSxnREFBR0EsQ0FBQzJGLEdBQUcsQ0FBQztZQUMvQixNQUFNdkQsT0FBT21DLFNBQVNuQyxJQUFJO1lBQzFCLE9BQU9BLEtBQUt1RSxhQUFhLElBQUksQ0FBQztRQUNoQyxFQUFFLE9BQU9qRixPQUFPO1lBQ2QsT0FBTyxDQUFDO1FBQ1Y7SUFDRjs7YUExV1FwQixTQUF3QjthQUN4QkcsVUFBVW1HLHVCQUErQixJQUFJO2FBQzdDekUsbUJBQXNDLEVBQUU7YUFDeENFLHNCQUE0QyxFQUFFO2FBQzlDZCw0QkFBd0QsRUFBRTthQUMxRGlCLGtCQUFvQyxFQUFFO2FBQ3RDRSx5QkFBa0QsRUFBRTthQUNwRHBCLG9CQUFvQjthQUNwQnFCLHVCQUF1QjthQUN2Qm5DLGVBQWU7YUFDZjRELGNBQXFDO2FBQ3JDakUsaUJBQXVDOztBQWdXakQ7QUFFTyxNQUFNNEcsY0FBYyxJQUFJOUcsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvY2hhdFJlYWxUaW1lLnRzPzQ3MDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xyXG5pbXBvcnQgYXBpIGZyb20gJ0AvbGliL2FwaSc7XHJcblxyXG5pbnRlcmZhY2UgQ2hhdE1lc3NhZ2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgc2VuZGVyX2lkOiBzdHJpbmc7XHJcbiAgcmVjZWl2ZXJfaWQ/OiBzdHJpbmc7XHJcbiAgc2VuZGVyX25hbWU6IHN0cmluZztcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgaXNfbWluZTogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgc3VwYWJhc2VfaWQ/OiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsPzogc3RyaW5nO1xyXG4gIHNwZWNpYWx0eT86IHN0cmluZztcclxuICBzdGF0dXM6ICdvbmxpbmUnIHwgJ29mZmxpbmUnO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTWVzc2FnZUNhbGxiYWNrIHtcclxuICAobWVzc2FnZTogQ2hhdE1lc3NhZ2UpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlclN0YXR1c0NhbGxiYWNrIHtcclxuICAodXNlcklkOiBzdHJpbmcsIHN0YXR1czogJ29ubGluZScgfCAnb2ZmbGluZScpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrIHtcclxuICAoY29ubmVjdGVkOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFR5cGluZ0NhbGxiYWNrIHtcclxuICAodXNlcklkOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVucmVhZE1lc3NhZ2VDYWxsYmFjayB7XHJcbiAgKGRhdGE6IHsgc2VuZGVyX2lkOiBzdHJpbmc7IHNlbmRlcl9uYW1lOiBzdHJpbmc7IG1lc3NhZ2VfcHJldmlldzogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZyB9KTogdm9pZDtcclxufVxyXG5cclxuY2xhc3MgQ2hhdFNlcnZpY2Uge1xyXG4gIHByaXZhdGUgc29ja2V0OiBTb2NrZXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjUwMDAnO1xyXG4gIHByaXZhdGUgbWVzc2FnZUNhbGxiYWNrczogTWVzc2FnZUNhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHVzZXJTdGF0dXNDYWxsYmFja3M6IFVzZXJTdGF0dXNDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSBjb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzOiBDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgdHlwaW5nQ2FsbGJhY2tzOiBUeXBpbmdDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSB1bnJlYWRNZXNzYWdlQ2FsbGJhY2tzOiBVbnJlYWRNZXNzYWdlQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gIHByaXZhdGUgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAzO1xyXG4gIHByaXZhdGUgaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSB0eXBpbmdUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGNvbm5lY3RQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBTaSB5YSB0ZW5lbW9zIHVuYSBwcm9tZXNhIGRlIGNvbmV4acOzbiBlbiBjdXJzbywgbGEgcmV0b3JuYW1vc1xyXG4gICAgaWYgKHRoaXMuY29ubmVjdFByb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnNvY2tldD8uY29ubmVjdGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5zb2NrZXQgPSBpbyh0aGlzLmJhc2VVcmwsIHtcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwb3J0czogWydwb2xsaW5nJywgJ3dlYnNvY2tldCddLFxyXG4gICAgICAgIHRpbWVvdXQ6IDIwMDAwLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcclxuICAgICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogMyxcclxuICAgICAgICByZWNvbm5lY3Rpb25EZWxheTogMjAwMCxcclxuICAgICAgICByZWNvbm5lY3Rpb25EZWxheU1heDogMTAwMDAsXHJcbiAgICAgICAgZm9yY2VOZXc6IGZhbHNlLFxyXG4gICAgICAgIGF1dG9Db25uZWN0OiB0cnVlLFxyXG4gICAgICAgIHVwZ3JhZGU6IHRydWUsXHJcbiAgICAgICAgcmVtZW1iZXJVcGdyYWRlOiBmYWxzZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodHJ1ZSkpO1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhmYWxzZSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNvbG8gaW50ZW50YXIgcmVjb25lY3RhciBhdXRvbcOhdGljYW1lbnRlIGVuIGVycm9yZXMgZGUgcmVkXHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3hociBwb2xsIGVycm9yJykpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDIwMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb246IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SMIFNvY2tldC5JTyBkaXNjb25uZWN0ZWQ6JywgcmVhc29uKTtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXV0by1yZWNvbmVjdGFyIHNvbG8gc2kgbm8gZnVlIHVuYSBkZXNjb25leGnDs24gaW50ZW5jaW9uYWxcclxuICAgICAgICBpZiAocmVhc29uICE9PSAnaW8gY2xpZW50IGRpc2Nvbm5lY3QnICYmIHJlYXNvbiAhPT0gJ2lvIHNlcnZlciBkaXNjb25uZWN0Jykge1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgMjAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFRpbWVvdXQgbcOhcyBnZW5lcm9zbyBwYXJhIHBlcm1pdGlyIGxhIGNvbmV4acOzblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBTb2NrZXQuSU8gY29ubmVjdGlvbiB0aW1lb3V0LCBmYWxsaW5nIGJhY2sgdG8gSFRUUCcpO1xyXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9LCAxNTAwMCk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignbmV3X21lc3NhZ2UnLCAobWVzc2FnZTogQ2hhdE1lc3NhZ2UpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TqCBOZXcgbWVzc2FnZSByZWNlaXZlZDonLCBtZXNzYWdlKTtcclxuICAgICAgICAvLyBNb3N0cmFyIG5vdGlmaWNhY2nDs24gZGUgbnVldm8gbWVuc2FqZVxyXG4gICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhtZXNzYWdlKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2Vfc2VudCcsIChtZXNzYWdlOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIE1lc3NhZ2Ugc2VudCBjb25maXJtYXRpb246JywgbWVzc2FnZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ3VzZXJfc3RhdHVzJywgKGRhdGE6IHsgdXNlcl9pZDogc3RyaW5nOyBzdGF0dXM6ICdvbmxpbmUnIHwgJ29mZmxpbmUnIH0pID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+RpCBVc2VyIHN0YXR1cyBjaGFuZ2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YS51c2VyX2lkLCBkYXRhLnN0YXR1cykpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCd1c2VyX3R5cGluZycsIChkYXRhOiB7IHVzZXJfaWQ6IHN0cmluZzsgaXNfdHlwaW5nOiBib29sZWFuIH0pID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4oyo77iPIFVzZXIgdHlwaW5nOicsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YS51c2VyX2lkLCBkYXRhLmlzX3R5cGluZykpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCd1bnJlYWRfbWVzc2FnZScsIChkYXRhOiB7IHNlbmRlcl9pZDogc3RyaW5nOyBzZW5kZXJfbmFtZTogc3RyaW5nOyBtZXNzYWdlX3ByZXZpZXc6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SUIFVucmVhZCBtZXNzYWdlIG5vdGlmaWNhdGlvbjonLCBkYXRhKTtcclxuICAgICAgICB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2VfZXJyb3InLCAoZXJyb3I6IHsgZXJyb3I6IHN0cmluZyB9KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE1lc3NhZ2UgZXJyb3I6JywgZXJyb3IuZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhdHRlbXB0UmVjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPj0gdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIDMwMDAwKTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLnNvY2tldD8uY29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBudWxsOyAvLyBSZXNldCBwcm9taXNlXHJcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGRlbGF5KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlOiBDaGF0TWVzc2FnZSk6IHZvaWQge1xyXG4gICAgLy8gU29sbyBtb3N0cmFyIG5vdGlmaWNhY2nDs24gc2kgZWwgdXN1YXJpbyBubyBlc3TDoSBlbiBsYSBww6FnaW5hIGRlbCBjaGF0XHJcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xyXG4gICAgICAgIG5ldyBOb3RpZmljYXRpb24oYE51ZXZvIG1lbnNhamUgZGUgJHttZXNzYWdlLnNlbmRlcl9uYW1lfWAsIHtcclxuICAgICAgICAgIGJvZHk6IG1lc3NhZ2UubWVzc2FnZSxcclxuICAgICAgICAgIGljb246ICcvZmF2aWNvbi5pY28nLFxyXG4gICAgICAgICAgdGFnOiAnY2hhdC1tZXNzYWdlJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XHJcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5zb2NrZXQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IHByb21pc2VcclxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgfVxyXG5cclxuICBpc1NvY2tldENvbm5lY3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnNvY2tldD8uY29ubmVjdGVkIHx8IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2VuZE1lc3NhZ2UocmVjZWl2ZXJJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICB0aGlzLnNlbmRNZXNzYWdlSHR0cChyZWNlaXZlcklkLCBtZXNzYWdlKS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW52aWFuZG8gbWVuc2FqZSBwb3IgSFRUUDonLCBlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb2NrZXQuZW1pdCgnc2VuZF9tZXNzYWdlJywge1xyXG4gICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzZW5kVHlwaW5nSW5kaWNhdG9yKHJlY2VpdmVySWQ6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnNvY2tldD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ3R5cGluZycsIHtcclxuICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgICBpc190eXBpbmc6IGlzVHlwaW5nXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhcnRUeXBpbmcocmVjZWl2ZXJJZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZCwgdHJ1ZSk7XHJcbiAgICBcclxuICAgIC8vIExpbXBpYXIgdGltZXIgYW50ZXJpb3Igc2kgZXhpc3RlXHJcbiAgICBpZiAodGhpcy50eXBpbmdUaW1lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50eXBpbmdUaW1lcik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEVudmlhciBcInN0b3AgdHlwaW5nXCIgZGVzcHXDqXMgZGUgMyBzZWd1bmRvc1xyXG4gICAgdGhpcy50eXBpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZCwgZmFsc2UpO1xyXG4gICAgfSwgMzAwMCk7XHJcbiAgfVxyXG5cclxuICBzdG9wVHlwaW5nKHJlY2VpdmVySWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMudHlwaW5nVGltZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHlwaW5nVGltZXIpO1xyXG4gICAgICB0aGlzLnR5cGluZ1RpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuc2VuZFR5cGluZ0luZGljYXRvcihyZWNlaXZlcklkLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kTWVzc2FnZUh0dHAocmVjZWl2ZXJJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPENoYXRNZXNzYWdlPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvc2VuZC1tZXNzYWdlJywge1xyXG4gICAgICAgIHJlY2VpdmVyX2lkOiByZWNlaXZlcklkLFxyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YTogQ2hhdE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmRhdGEuaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBzZW5kZXJfaWQ6IHJlc3BvbnNlLmRhdGEuc2VuZGVyX2lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgcmVjZWl2ZXJfaWQ6IHJlc3BvbnNlLmRhdGEucmVjZWl2ZXJfaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBzZW5kZXJfbmFtZTogJ1TDuicsXHJcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZGF0YS5tZXNzYWdlLFxyXG4gICAgICAgIHRpbWVzdGFtcDogcmVzcG9uc2UuZGF0YS50aW1lc3RhbXAsXHJcbiAgICAgICAgaXNfbWluZTogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gTm90aWZpY2FyIGEgbG9zIGNhbGxiYWNrc1xyXG4gICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhtZXNzYWdlRGF0YSkpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG1lc3NhZ2VEYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lc3NhZ2UoY2FsbGJhY2s6IE1lc3NhZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZUNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9uVXNlclN0YXR1c0NoYW5nZShjYWxsYmFjazogVXNlclN0YXR1c0NhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLnVzZXJTdGF0dXNDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb25Db25uZWN0aW9uU3RhdHVzKGNhbGxiYWNrOiBDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvblR5cGluZyhjYWxsYmFjazogVHlwaW5nQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMudHlwaW5nQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvblVucmVhZE1lc3NhZ2UoY2FsbGJhY2s6IFVucmVhZE1lc3NhZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5yZWFkTWVzc2FnZUNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uKCk6IHZvaWQge1xyXG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdyAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0TWVzc2FnZXMocmVjZWl2ZXJJZDogc3RyaW5nKTogUHJvbWlzZTxDaGF0TWVzc2FnZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVc2FyIGxhIG51ZXZhIHJ1dGEgcXVlIG1hbmVqYSBVVUlEc1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9nZXQtbWVzc2FnZXMtdXVpZC8ke3JlY2VpdmVySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1lc3NhZ2VzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VycygpOiBQcm9taXNlPFVzZXJbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvZ2V0LWNoYXQtZG9jdG9ycycpO1xyXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgcmV0dXJuIGRhdGEuZG9jdG9ycz8ubWFwKChkb2N0b3I6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogZG9jdG9yLmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc3VwYWJhc2VfaWQ6IGRvY3Rvci5zdXBhYmFzZV9pZCxcclxuICAgICAgICBuYW1lOiBgJHtkb2N0b3IuZmlyc3ROYW1lfSAke2RvY3Rvci5sYXN0TmFtZTF9YCxcclxuICAgICAgICBlbWFpbDogZG9jdG9yLmVtYWlsLFxyXG4gICAgICAgIHNwZWNpYWx0eTogZG9jdG9yLnNwZWNpYWxpdHksXHJcbiAgICAgICAgc3RhdHVzOiAnb2ZmbGluZScgYXMgY29uc3RcclxuICAgICAgfSkpIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJzEnLFxyXG4gICAgICAgICAgc3VwYWJhc2VfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksICAvLyBHZW5lcmFyIFVVSUQgcmVhbFxyXG4gICAgICAgICAgbmFtZTogJ0RyLiBKdWFuIFDDqXJleicsXHJcbiAgICAgICAgICBlbWFpbDogJ2p1YW4ucGVyZXpAaG9zcGl0YWwuY29tJyxcclxuICAgICAgICAgIHNwZWNpYWx0eTogJ0NhcmRpb2xvZ8OtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvbmxpbmUnIGFzIGNvbnN0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJzInLFxyXG4gICAgICAgICAgc3VwYWJhc2VfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksICAvLyBHZW5lcmFyIFVVSUQgcmVhbFxyXG4gICAgICAgICAgbmFtZTogJ0RyYS4gTWFyw61hIEdvbnrDoWxleicsXHJcbiAgICAgICAgICBlbWFpbDogJ21hcmlhLmdvbnphbGV6QGhvc3BpdGFsLmNvbScsXHJcbiAgICAgICAgICBzcGVjaWFsdHk6ICdOZXVyb2xvZ8OtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvZmZsaW5lJyBhcyBjb25zdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICczJyxcclxuICAgICAgICAgIHN1cGFiYXNlX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLCAgLy8gR2VuZXJhciBVVUlEIHJlYWxcclxuICAgICAgICAgIG5hbWU6ICdEci4gQ2FybG9zIEzDs3BleicsXHJcbiAgICAgICAgICBlbWFpbDogJ2Nhcmxvcy5sb3BlekBob3NwaXRhbC5jb20nLFxyXG4gICAgICAgICAgc3BlY2lhbHR5OiAnUGVkaWF0csOtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvZmZsaW5lJyBhcyBjb25zdFxyXG4gICAgICAgIH1cclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVucmVhZENvdW50cygpOiBQcm9taXNlPHsgW3VzZXJJZDogc3RyaW5nXTogbnVtYmVyIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2dldC11bnJlYWQtY291bnRzJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICByZXR1cm4gZGF0YS51bnJlYWRfY291bnRzIHx8IHt9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNoYXRTZXJ2aWNlID0gbmV3IENoYXRTZXJ2aWNlKCk7XHJcbmV4cG9ydCB0eXBlIHsgQ2hhdE1lc3NhZ2UsIFVzZXIsIENvbm5lY3Rpb25TdGF0dXNDYWxsYmFjaywgVHlwaW5nQ2FsbGJhY2ssIFVucmVhZE1lc3NhZ2VDYWxsYmFjayB9O1xyXG4iXSwibmFtZXMiOlsiaW8iLCJhcGkiLCJDaGF0U2VydmljZSIsImNvbm5lY3QiLCJjb25uZWN0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic29ja2V0IiwiY29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiYmFzZVVybCIsIndpdGhDcmVkZW50aWFscyIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0IiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwiZm9yY2VOZXciLCJhdXRvQ29ubmVjdCIsInVwZ3JhZGUiLCJyZW1lbWJlclVwZ3JhZGUiLCJvbiIsInJlY29ubmVjdEF0dGVtcHRzIiwiY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcyIsImZvckVhY2giLCJjYWxsYmFjayIsImVycm9yIiwibWVzc2FnZSIsImluY2x1ZGVzIiwic2V0VGltZW91dCIsImF0dGVtcHRSZWNvbm5lY3QiLCJyZWFzb24iLCJjb25zb2xlIiwibG9nIiwic2hvd05vdGlmaWNhdGlvbiIsIm1lc3NhZ2VDYWxsYmFja3MiLCJkYXRhIiwidXNlclN0YXR1c0NhbGxiYWNrcyIsInVzZXJfaWQiLCJzdGF0dXMiLCJ0eXBpbmdDYWxsYmFja3MiLCJpc190eXBpbmciLCJ1bnJlYWRNZXNzYWdlQ2FsbGJhY2tzIiwibWF4UmVjb25uZWN0QXR0ZW1wdHMiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJ3aW5kb3ciLCJOb3RpZmljYXRpb24iLCJwZXJtaXNzaW9uIiwiZG9jdW1lbnQiLCJoaWRkZW4iLCJzZW5kZXJfbmFtZSIsImJvZHkiLCJpY29uIiwidGFnIiwiZGlzY29ubmVjdCIsImlzU29ja2V0Q29ubmVjdGVkIiwic2VuZE1lc3NhZ2UiLCJyZWNlaXZlcklkIiwic2VuZE1lc3NhZ2VIdHRwIiwiY2F0Y2giLCJlbWl0IiwicmVjZWl2ZXJfaWQiLCJzZW5kVHlwaW5nSW5kaWNhdG9yIiwiaXNUeXBpbmciLCJzdGFydFR5cGluZyIsInR5cGluZ1RpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic3RvcFR5cGluZyIsInJlc3BvbnNlIiwicG9zdCIsIm1lc3NhZ2VEYXRhIiwiaWQiLCJ0b1N0cmluZyIsInNlbmRlcl9pZCIsInRpbWVzdGFtcCIsImlzX21pbmUiLCJvbk1lc3NhZ2UiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwib25Vc2VyU3RhdHVzQ2hhbmdlIiwib25Db25uZWN0aW9uU3RhdHVzIiwib25UeXBpbmciLCJvblVucmVhZE1lc3NhZ2UiLCJyZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbiIsInJlcXVlc3RQZXJtaXNzaW9uIiwiZ2V0TWVzc2FnZXMiLCJnZXQiLCJtZXNzYWdlcyIsImdldFVzZXJzIiwiZG9jdG9ycyIsIm1hcCIsImRvY3RvciIsInN1cGFiYXNlX2lkIiwibmFtZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lMSIsImVtYWlsIiwic3BlY2lhbHR5Iiwic3BlY2lhbGl0eSIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJnZXRVbnJlYWRDb3VudHMiLCJ1bnJlYWRfY291bnRzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJjaGF0U2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatRealTime.ts\n"));

/***/ })

});