"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/services/chatRealTime.ts":
/*!**************************************!*\
  !*** ./src/services/chatRealTime.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: function() { return /* binding */ chatService; }\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n\n\nclass ChatService {\n    connect() {\n        // Si ya tenemos una promesa de conexión en curso, la retornamos\n        if (this.connectPromise) {\n            return this.connectPromise;\n        }\n        this.connectPromise = new Promise((resolve)=>{\n            var _this_socket;\n            if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n                resolve();\n                return;\n            }\n            if (this.isConnecting) {\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(this.baseUrl, {\n                withCredentials: true,\n                transports: [\n                    \"polling\",\n                    \"websocket\"\n                ],\n                timeout: 20000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                reconnectionDelay: 2000,\n                reconnectionDelayMax: 10000,\n                forceNew: false,\n                autoConnect: true,\n                upgrade: true,\n                rememberUpgrade: false\n            });\n            this.socket.on(\"connect\", ()=>{\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(true));\n                resolve();\n            });\n            this.socket.on(\"connect_error\", (error)=>{\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Solo intentar reconectar automáticamente en errores de red\n                if (error.message && !error.message.includes(\"xhr poll error\")) {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            this.socket.on(\"disconnect\", (reason)=>{\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Auto-reconectar solo si no fue una desconexión intencional\n                if (reason !== \"io client disconnect\" && reason !== \"io server disconnect\") {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            // Timeout más generoso para permitir la conexión\n            setTimeout(()=>{\n                var _this_socket;\n                this.isConnecting = false;\n                if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                    this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                }\n                resolve();\n            }, 15000);\n            this.socket.on(\"new_message\", (message)=>{\n                this.showNotification(message);\n                this.messageCallbacks.forEach((callback)=>callback(message));\n            });\n            this.socket.on(\"message_sent\", (message)=>{\n            // Mensaje enviado exitosamente\n            });\n            this.socket.on(\"user_status\", (data)=>{\n                this.userStatusCallbacks.forEach((callback)=>callback(data.user_id, data.status));\n            });\n            this.socket.on(\"user_typing\", (data)=>{\n                this.typingCallbacks.forEach((callback)=>callback(data.user_id, data.is_typing));\n            });\n            this.socket.on(\"unread_message\", (data)=>{\n                this.unreadMessageCallbacks.forEach((callback)=>callback(data));\n            });\n            this.socket.on(\"message_error\", (error)=>{\n            // Error handling\n            });\n        });\n        return this.connectPromise;\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n        setTimeout(()=>{\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                this.connectPromise = null; // Reset promise\n                this.connect();\n            }\n        }, delay);\n    }\n    showNotification(message) {\n        // Solo mostrar notificación si el usuario no está en la página del chat\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            if (document.hidden) {\n                new Notification(\"Nuevo mensaje de \".concat(message.sender_name), {\n                    body: message.message,\n                    icon: \"/favicon.ico\",\n                    tag: \"chat-message\"\n                });\n            }\n        }\n    }\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectPromise = null; // Reset promise\n        this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n    }\n    isSocketConnected() {\n        var _this_socket;\n        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;\n    }\n    sendMessage(receiverId, message) {\n        var _this_socket;\n        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n            this.sendMessageHttp(receiverId, message).catch((error)=>{\n                console.error(\"Error enviando mensaje por HTTP:\", error);\n            });\n            return;\n        }\n        this.socket.emit(\"send_message\", {\n            receiver_id: receiverId,\n            message: message\n        });\n    }\n    sendTypingIndicator(receiverId, isTyping) {\n        var _this_socket;\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            this.socket.emit(\"typing\", {\n                receiver_id: receiverId,\n                is_typing: isTyping\n            });\n        }\n    }\n    startTyping(receiverId) {\n        this.sendTypingIndicator(receiverId, true);\n        // Limpiar timer anterior si existe\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n        }\n        // Enviar \"stop typing\" después de 3 segundos\n        this.typingTimer = setTimeout(()=>{\n            this.sendTypingIndicator(receiverId, false);\n        }, 3000);\n    }\n    stopTyping(receiverId) {\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n            this.typingTimer = null;\n        }\n        this.sendTypingIndicator(receiverId, false);\n    }\n    async sendMessageHttp(receiverId, message) {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/send-message\", {\n                receiver_id: receiverId,\n                message: message\n            });\n            const messageData = {\n                id: response.data.id.toString(),\n                sender_id: response.data.sender_id.toString(),\n                receiver_id: response.data.receiver_id.toString(),\n                sender_name: \"T\\xfa\",\n                message: response.data.message,\n                timestamp: response.data.timestamp,\n                is_mine: true\n            };\n            // Notificar a los callbacks\n            this.messageCallbacks.forEach((callback)=>callback(messageData));\n            return messageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n    onMessage(callback) {\n        this.messageCallbacks.push(callback);\n        return ()=>{\n            const index = this.messageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.messageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUserStatusChange(callback) {\n        this.userStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.userStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.userStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onConnectionStatus(callback) {\n        this.connectionStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.connectionStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.connectionStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onTyping(callback) {\n        this.typingCallbacks.push(callback);\n        return ()=>{\n            const index = this.typingCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.typingCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUnreadMessage(callback) {\n        this.unreadMessageCallbacks.push(callback);\n        return ()=>{\n            const index = this.unreadMessageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.unreadMessageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    requestNotificationPermission() {\n        if (\"Notification\" in window && Notification.permission === \"default\") {\n            Notification.requestPermission();\n        }\n    }\n    async getMessages(receiverId) {\n        try {\n            // Usar la nueva ruta que maneja UUIDs\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-messages-uuid/\".concat(receiverId));\n            return response.data.messages || [];\n        } catch (error) {\n            throw error;\n        }\n    }\n    async getUsers() {\n        try {\n            var _data_doctors;\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-chat-doctors\");\n            const data = response.data;\n            return ((_data_doctors = data.doctors) === null || _data_doctors === void 0 ? void 0 : _data_doctors.map((doctor)=>({\n                    id: doctor.id.toString(),\n                    supabase_id: doctor.supabase_id,\n                    name: \"\".concat(doctor.firstName, \" \").concat(doctor.lastName1),\n                    email: doctor.email,\n                    specialty: doctor.speciality,\n                    status: \"offline\"\n                }))) || [];\n        } catch (error) {\n            return [\n                {\n                    id: \"1\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Juan P\\xe9rez\",\n                    email: \"juan.perez@hospital.com\",\n                    specialty: \"Cardiolog\\xeda\",\n                    status: \"online\"\n                },\n                {\n                    id: \"2\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dra. Mar\\xeda Gonz\\xe1lez\",\n                    email: \"maria.gonzalez@hospital.com\",\n                    specialty: \"Neurolog\\xeda\",\n                    status: \"offline\"\n                },\n                {\n                    id: \"3\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Carlos L\\xf3pez\",\n                    email: \"carlos.lopez@hospital.com\",\n                    specialty: \"Pediatr\\xeda\",\n                    status: \"offline\"\n                }\n            ];\n        }\n    }\n    async getUnreadCounts() {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-unread-counts\");\n            const data = response.data;\n            return data.unread_counts || {};\n        } catch (error) {\n            return {};\n        }\n    }\n    constructor(){\n        this.socket = null;\n        this.baseUrl = \"http://localhost:5000\" || 0;\n        this.messageCallbacks = [];\n        this.userStatusCallbacks = [];\n        this.connectionStatusCallbacks = [];\n        this.typingCallbacks = [];\n        this.unreadMessageCallbacks = [];\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.isConnecting = false;\n        this.typingTimer = null;\n        this.connectPromise = null;\n    }\n}\nconst chatService = new ChatService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0UmVhbFRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ2xCO0FBeUM1QixNQUFNRTtJQWNKQyxVQUF5QjtRQUN2QixnRUFBZ0U7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzdCO1lBQUosS0FBSSxtQkFBSSxDQUFDQyxNQUFNLGNBQVgsZ0RBQWFDLFNBQVMsRUFBRTtnQkFDMUJGO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ0csWUFBWSxFQUFFO2dCQUNyQkg7Z0JBQ0E7WUFDRjtZQUVBLElBQUksQ0FBQ0csWUFBWSxHQUFHO1lBRXBCLElBQUksQ0FBQ0YsTUFBTSxHQUFHUCxvREFBRUEsQ0FBQyxJQUFJLENBQUNVLE9BQU8sRUFBRTtnQkFDN0JDLGlCQUFpQjtnQkFDakJDLFlBQVk7b0JBQUM7b0JBQVc7aUJBQVk7Z0JBQ3BDQyxTQUFTO2dCQUNUQyxjQUFjO2dCQUNkQyxzQkFBc0I7Z0JBQ3RCQyxtQkFBbUI7Z0JBQ25CQyxzQkFBc0I7Z0JBQ3RCQyxVQUFVO2dCQUNWQyxhQUFhO2dCQUNiQyxTQUFTO2dCQUNUQyxpQkFBaUI7WUFDbkI7WUFFQSxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsRUFBRSxDQUFDLFdBQVc7Z0JBQ3hCLElBQUksQ0FBQ2IsWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNjLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLHlCQUF5QixDQUFDQyxPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7Z0JBQzVEcEI7WUFDRjtZQUVBLElBQUksQ0FBQ0MsTUFBTSxDQUFDZSxFQUFFLENBQUMsaUJBQWlCLENBQUNLO2dCQUMvQixJQUFJLENBQUNsQixZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FB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QUF3QjthQUN4QkcsVUFBVWtHLHVCQUErQixJQUFJO2FBQzdDMUUsbUJBQXNDLEVBQUU7YUFDeENFLHNCQUE0QyxFQUFFO2FBQzlDWiw0QkFBd0QsRUFBRTthQUMxRGUsa0JBQW9DLEVBQUU7YUFDdENFLHlCQUFrRCxFQUFFO2FBQ3BEbEIsb0JBQW9CO2FBQ3BCbUIsdUJBQXVCO2FBQ3ZCakMsZUFBZTthQUNmMkQsY0FBcUM7YUFDckNoRSxpQkFBdUM7O0FBeVZqRDtBQUVPLE1BQU0yRyxjQUFjLElBQUk3RyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9jaGF0UmVhbFRpbWUudHM/NDcwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XHJcbmltcG9ydCBhcGkgZnJvbSAnQC9saWIvYXBpJztcclxuXHJcbmludGVyZmFjZSBDaGF0TWVzc2FnZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBzZW5kZXJfaWQ6IHN0cmluZztcclxuICByZWNlaXZlcl9pZD86IHN0cmluZztcclxuICBzZW5kZXJfbmFtZTogc3RyaW5nO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBpc19taW5lOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlciB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBzdXBhYmFzZV9pZD86IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZW1haWw/OiBzdHJpbmc7XHJcbiAgc3BlY2lhbHR5Pzogc3RyaW5nO1xyXG4gIHN0YXR1czogJ29ubGluZScgfCAnb2ZmbGluZSc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBNZXNzYWdlQ2FsbGJhY2sge1xyXG4gIChtZXNzYWdlOiBDaGF0TWVzc2FnZSk6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBVc2VyU3RhdHVzQ2FsbGJhY2sge1xyXG4gICh1c2VySWQ6IHN0cmluZywgc3RhdHVzOiAnb25saW5lJyB8ICdvZmZsaW5lJyk6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2sge1xyXG4gIChjb25uZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVHlwaW5nQ2FsbGJhY2sge1xyXG4gICh1c2VySWQ6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVW5yZWFkTWVzc2FnZUNhbGxiYWNrIHtcclxuICAoZGF0YTogeyBzZW5kZXJfaWQ6IHN0cmluZzsgc2VuZGVyX25hbWU6IHN0cmluZzsgbWVzc2FnZV9wcmV2aWV3OiBzdHJpbmc7IHRpbWVzdGFtcDogc3RyaW5nIH0pOiB2b2lkO1xyXG59XHJcblxyXG5jbGFzcyBDaGF0U2VydmljZSB7XHJcbiAgcHJpdmF0ZSBzb2NrZXQ6IFNvY2tldCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMCc7XHJcbiAgcHJpdmF0ZSBtZXNzYWdlQ2FsbGJhY2tzOiBNZXNzYWdlQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgdXNlclN0YXR1c0NhbGxiYWNrczogVXNlclN0YXR1c0NhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIGNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3M6IENvbm5lY3Rpb25TdGF0dXNDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSB0eXBpbmdDYWxsYmFja3M6IFR5cGluZ0NhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHVucmVhZE1lc3NhZ2VDYWxsYmFja3M6IFVucmVhZE1lc3NhZ2VDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSByZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgcHJpdmF0ZSBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDM7XHJcbiAgcHJpdmF0ZSBpc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICBwcml2YXRlIHR5cGluZ1RpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgY29ubmVjdFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFNpIHlhIHRlbmVtb3MgdW5hIHByb21lc2EgZGUgY29uZXhpw7NuIGVuIGN1cnNvLCBsYSByZXRvcm5hbW9zXHJcbiAgICBpZiAodGhpcy5jb25uZWN0UHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0UHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgaWYgKHRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWU7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnNvY2tldCA9IGlvKHRoaXMuYmFzZVVybCwge1xyXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcclxuICAgICAgICB0cmFuc3BvcnRzOiBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J10sXHJcbiAgICAgICAgdGltZW91dDogMjAwMDAsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uOiB0cnVlLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiAzLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiAyMDAwLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiAxMDAwMCxcclxuICAgICAgICBmb3JjZU5ldzogZmFsc2UsXHJcbiAgICAgICAgYXV0b0Nvbm5lY3Q6IHRydWUsXHJcbiAgICAgICAgdXBncmFkZTogdHJ1ZSxcclxuICAgICAgICByZW1lbWJlclVwZ3JhZGU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0cnVlKSk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU29sbyBpbnRlbnRhciByZWNvbmVjdGFyIGF1dG9tw6F0aWNhbWVudGUgZW4gZXJyb3JlcyBkZSByZWRcclxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSAmJiAhZXJyb3IubWVzc2FnZS5pbmNsdWRlcygneGhyIHBvbGwgZXJyb3InKSkge1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgMjAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKHJlYXNvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhmYWxzZSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEF1dG8tcmVjb25lY3RhciBzb2xvIHNpIG5vIGZ1ZSB1bmEgZGVzY29uZXhpw7NuIGludGVuY2lvbmFsXHJcbiAgICAgICAgaWYgKHJlYXNvbiAhPT0gJ2lvIGNsaWVudCBkaXNjb25uZWN0JyAmJiByZWFzb24gIT09ICdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDIwMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBUaW1lb3V0IG3DoXMgZ2VuZXJvc28gcGFyYSBwZXJtaXRpciBsYSBjb25leGnDs25cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSwgMTUwMDApO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ25ld19tZXNzYWdlJywgKG1lc3NhZ2U6IENoYXRNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKG1lc3NhZ2UpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignbWVzc2FnZV9zZW50JywgKG1lc3NhZ2U6IGFueSkgPT4ge1xyXG4gICAgICAgIC8vIE1lbnNhamUgZW52aWFkbyBleGl0b3NhbWVudGVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbigndXNlcl9zdGF0dXMnLCAoZGF0YTogeyB1c2VyX2lkOiBzdHJpbmc7IHN0YXR1czogJ29ubGluZScgfCAnb2ZmbGluZScgfSkgPT4ge1xyXG4gICAgICAgIHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEudXNlcl9pZCwgZGF0YS5zdGF0dXMpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbigndXNlcl90eXBpbmcnLCAoZGF0YTogeyB1c2VyX2lkOiBzdHJpbmc7IGlzX3R5cGluZzogYm9vbGVhbiB9KSA9PiB7XHJcbiAgICAgICAgdGhpcy50eXBpbmdDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhLnVzZXJfaWQsIGRhdGEuaXNfdHlwaW5nKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ3VucmVhZF9tZXNzYWdlJywgKGRhdGE6IHsgc2VuZGVyX2lkOiBzdHJpbmc7IHNlbmRlcl9uYW1lOiBzdHJpbmc7IG1lc3NhZ2VfcHJldmlldzogc3RyaW5nOyB0aW1lc3RhbXA6IHN0cmluZyB9KSA9PiB7XHJcbiAgICAgICAgdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YSkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlX2Vycm9yJywgKGVycm9yOiB7IGVycm9yOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgIC8vIEVycm9yIGhhbmRsaW5nXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGF0dGVtcHRSZWNvbm5lY3QoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+PSB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XHJcbiAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKDEwMDAgKiBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgMzAwMDApO1xyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IHByb21pc2VcclxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcclxuICAgICAgfVxyXG4gICAgfSwgZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogdm9pZCB7XHJcbiAgICAvLyBTb2xvIG1vc3RyYXIgbm90aWZpY2FjacOzbiBzaSBlbCB1c3VhcmlvIG5vIGVzdMOhIGVuIGxhIHDDoWdpbmEgZGVsIGNoYXRcclxuICAgIGlmICgnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdncmFudGVkJykge1xyXG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XHJcbiAgICAgICAgbmV3IE5vdGlmaWNhdGlvbihgTnVldm8gbWVuc2FqZSBkZSAke21lc3NhZ2Uuc2VuZGVyX25hbWV9YCwge1xyXG4gICAgICAgICAgYm9keTogbWVzc2FnZS5tZXNzYWdlLFxyXG4gICAgICAgICAgaWNvbjogJy9mYXZpY29uLmljbycsXHJcbiAgICAgICAgICB0YWc6ICdjaGF0LW1lc3NhZ2UnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5zb2NrZXQpIHtcclxuICAgICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLnNvY2tldCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDsgLy8gUmVzZXQgcHJvbWlzZVxyXG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZmFsc2UpKTtcclxuICB9XHJcblxyXG4gIGlzU29ja2V0Q29ubmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc29ja2V0Py5jb25uZWN0ZWQgfHwgZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzZW5kTWVzc2FnZShyZWNlaXZlcklkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLnNvY2tldD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHRoaXMuc2VuZE1lc3NhZ2VIdHRwKHJlY2VpdmVySWQsIG1lc3NhZ2UpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnZpYW5kbyBtZW5zYWplIHBvciBIVFRQOicsIGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNvY2tldC5lbWl0KCdzZW5kX21lc3NhZ2UnLCB7XHJcbiAgICAgIHJlY2VpdmVyX2lkOiByZWNlaXZlcklkLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZDogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcclxuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgndHlwaW5nJywge1xyXG4gICAgICAgIHJlY2VpdmVyX2lkOiByZWNlaXZlcklkLFxyXG4gICAgICAgIGlzX3R5cGluZzogaXNUeXBpbmdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGFydFR5cGluZyhyZWNlaXZlcklkOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMuc2VuZFR5cGluZ0luZGljYXRvcihyZWNlaXZlcklkLCB0cnVlKTtcclxuICAgIFxyXG4gICAgLy8gTGltcGlhciB0aW1lciBhbnRlcmlvciBzaSBleGlzdGVcclxuICAgIGlmICh0aGlzLnR5cGluZ1RpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnR5cGluZ1RpbWVyKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRW52aWFyIFwic3RvcCB0eXBpbmdcIiBkZXNwdcOpcyBkZSAzIHNlZ3VuZG9zXHJcbiAgICB0aGlzLnR5cGluZ1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2VuZFR5cGluZ0luZGljYXRvcihyZWNlaXZlcklkLCBmYWxzZSk7XHJcbiAgICB9LCAzMDAwKTtcclxuICB9XHJcblxyXG4gIHN0b3BUeXBpbmcocmVjZWl2ZXJJZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy50eXBpbmdUaW1lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50eXBpbmdUaW1lcik7XHJcbiAgICAgIHRoaXMudHlwaW5nVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZW5kVHlwaW5nSW5kaWNhdG9yKHJlY2VpdmVySWQsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNlbmRNZXNzYWdlSHR0cChyZWNlaXZlcklkOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8Q2hhdE1lc3NhZ2U+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9zZW5kLW1lc3NhZ2UnLCB7XHJcbiAgICAgICAgcmVjZWl2ZXJfaWQ6IHJlY2VpdmVySWQsXHJcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhOiBDaGF0TWVzc2FnZSA9IHtcclxuICAgICAgICBpZDogcmVzcG9uc2UuZGF0YS5pZC50b1N0cmluZygpLFxyXG4gICAgICAgIHNlbmRlcl9pZDogcmVzcG9uc2UuZGF0YS5zZW5kZXJfaWQudG9TdHJpbmcoKSxcclxuICAgICAgICByZWNlaXZlcl9pZDogcmVzcG9uc2UuZGF0YS5yZWNlaXZlcl9pZC50b1N0cmluZygpLFxyXG4gICAgICAgIHNlbmRlcl9uYW1lOiAnVMO6JyxcclxuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5kYXRhLm1lc3NhZ2UsXHJcbiAgICAgICAgdGltZXN0YW1wOiByZXNwb25zZS5kYXRhLnRpbWVzdGFtcCxcclxuICAgICAgICBpc19taW5lOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBOb3RpZmljYXIgYSBsb3MgY2FsbGJhY2tzXHJcbiAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKG1lc3NhZ2VEYXRhKSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbWVzc2FnZURhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTWVzc2FnZShjYWxsYmFjazogTWVzc2FnZUNhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb25Vc2VyU3RhdHVzQ2hhbmdlKGNhbGxiYWNrOiBVc2VyU3RhdHVzQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnVzZXJTdGF0dXNDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvbkNvbm5lY3Rpb25TdGF0dXMoY2FsbGJhY2s6IENvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9uVHlwaW5nKGNhbGxiYWNrOiBUeXBpbmdDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy50eXBpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50eXBpbmdDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy50eXBpbmdDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9uVW5yZWFkTWVzc2FnZShjYWxsYmFjazogVW5yZWFkTWVzc2FnZUNhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMudW5yZWFkTWVzc2FnZUNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKTogdm9pZCB7XHJcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRNZXNzYWdlcyhyZWNlaXZlcklkOiBzdHJpbmcpOiBQcm9taXNlPENoYXRNZXNzYWdlW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzYXIgbGEgbnVldmEgcnV0YSBxdWUgbWFuZWphIFVVSURzXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldChgL2dldC1tZXNzYWdlcy11dWlkLyR7cmVjZWl2ZXJJZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWVzc2FnZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVzZXJzKCk6IFByb21pc2U8VXNlcltdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9nZXQtY2hhdC1kb2N0b3JzJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICByZXR1cm4gZGF0YS5kb2N0b3JzPy5tYXAoKGRvY3RvcjogYW55KSA9PiAoe1xyXG4gICAgICAgIGlkOiBkb2N0b3IuaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBzdXBhYmFzZV9pZDogZG9jdG9yLnN1cGFiYXNlX2lkLFxyXG4gICAgICAgIG5hbWU6IGAke2RvY3Rvci5maXJzdE5hbWV9ICR7ZG9jdG9yLmxhc3ROYW1lMX1gLFxyXG4gICAgICAgIGVtYWlsOiBkb2N0b3IuZW1haWwsXHJcbiAgICAgICAgc3BlY2lhbHR5OiBkb2N0b3Iuc3BlY2lhbGl0eSxcclxuICAgICAgICBzdGF0dXM6ICdvZmZsaW5lJyBhcyBjb25zdFxyXG4gICAgICB9KSkgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiAnMScsXHJcbiAgICAgICAgICBzdXBhYmFzZV9pZDogY3J5cHRvLnJhbmRvbVVVSUQoKSwgIC8vIEdlbmVyYXIgVVVJRCByZWFsXHJcbiAgICAgICAgICBuYW1lOiAnRHIuIEp1YW4gUMOpcmV6JyxcclxuICAgICAgICAgIGVtYWlsOiAnanVhbi5wZXJlekBob3NwaXRhbC5jb20nLFxyXG4gICAgICAgICAgc3BlY2lhbHR5OiAnQ2FyZGlvbG9nw61hJyxcclxuICAgICAgICAgIHN0YXR1czogJ29ubGluZScgYXMgY29uc3RcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiAnMicsXHJcbiAgICAgICAgICBzdXBhYmFzZV9pZDogY3J5cHRvLnJhbmRvbVVVSUQoKSwgIC8vIEdlbmVyYXIgVVVJRCByZWFsXHJcbiAgICAgICAgICBuYW1lOiAnRHJhLiBNYXLDrWEgR29uesOhbGV6JyxcclxuICAgICAgICAgIGVtYWlsOiAnbWFyaWEuZ29uemFsZXpAaG9zcGl0YWwuY29tJyxcclxuICAgICAgICAgIHNwZWNpYWx0eTogJ05ldXJvbG9nw61hJyxcclxuICAgICAgICAgIHN0YXR1czogJ29mZmxpbmUnIGFzIGNvbnN0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJzMnLFxyXG4gICAgICAgICAgc3VwYWJhc2VfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksICAvLyBHZW5lcmFyIFVVSUQgcmVhbFxyXG4gICAgICAgICAgbmFtZTogJ0RyLiBDYXJsb3MgTMOzcGV6JyxcclxuICAgICAgICAgIGVtYWlsOiAnY2FybG9zLmxvcGV6QGhvc3BpdGFsLmNvbScsXHJcbiAgICAgICAgICBzcGVjaWFsdHk6ICdQZWRpYXRyw61hJyxcclxuICAgICAgICAgIHN0YXR1czogJ29mZmxpbmUnIGFzIGNvbnN0XHJcbiAgICAgICAgfVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VW5yZWFkQ291bnRzKCk6IFByb21pc2U8eyBbdXNlcklkOiBzdHJpbmddOiBudW1iZXIgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvZ2V0LXVucmVhZC1jb3VudHMnKTtcclxuICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgIHJldHVybiBkYXRhLnVucmVhZF9jb3VudHMgfHwge307XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY2hhdFNlcnZpY2UgPSBuZXcgQ2hhdFNlcnZpY2UoKTtcclxuZXhwb3J0IHR5cGUgeyBDaGF0TWVzc2FnZSwgVXNlciwgQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrLCBUeXBpbmdDYWxsYmFjaywgVW5yZWFkTWVzc2FnZUNhbGxiYWNrIH07XHJcbiJdLCJuYW1lcyI6WyJpbyIsImFwaSIsIkNoYXRTZXJ2aWNlIiwiY29ubmVjdCIsImNvbm5lY3RQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzb2NrZXQiLCJjb25uZWN0ZWQiLCJpc0Nvbm5lY3RpbmciLCJiYXNlVXJsIiwid2l0aENyZWRlbnRpYWxzIiwidHJhbnNwb3J0cyIsInRpbWVvdXQiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJmb3JjZU5ldyIsImF1dG9Db25uZWN0IiwidXBncmFkZSIsInJlbWVtYmVyVXBncmFkZSIsIm9uIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJjb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJzZXRUaW1lb3V0IiwiYXR0ZW1wdFJlY29ubmVjdCIsInJlYXNvbiIsInNob3dOb3RpZmljYXRpb24iLCJtZXNzYWdlQ2FsbGJhY2tzIiwiZGF0YSIsInVzZXJTdGF0dXNDYWxsYmFja3MiLCJ1c2VyX2lkIiwic3RhdHVzIiwidHlwaW5nQ2FsbGJhY2tzIiwiaXNfdHlwaW5nIiwidW5yZWFkTWVzc2FnZUNhbGxiYWNrcyIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwiZGVsYXkiLCJNYXRoIiwibWluIiwicG93Iiwid2luZG93IiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsImRvY3VtZW50IiwiaGlkZGVuIiwic2VuZGVyX25hbWUiLCJib2R5IiwiaWNvbiIsInRhZyIsImRpc2Nvbm5lY3QiLCJpc1NvY2tldENvbm5lY3RlZCIsInNlbmRNZXNzYWdlIiwicmVjZWl2ZXJJZCIsInNlbmRNZXNzYWdlSHR0cCIsImNhdGNoIiwiY29uc29sZSIsImVtaXQiLCJyZWNlaXZlcl9pZCIsInNlbmRUeXBpbmdJbmRpY2F0b3IiLCJpc1R5cGluZyIsInN0YXJ0VHlwaW5nIiwidHlwaW5nVGltZXIiLCJjbGVhclRpbWVvdXQiLCJzdG9wVHlwaW5nIiwicmVzcG9uc2UiLCJwb3N0IiwibWVzc2FnZURhdGEiLCJpZCIsInRvU3RyaW5nIiwic2VuZGVyX2lkIiwidGltZXN0YW1wIiwiaXNfbWluZSIsIm9uTWVzc2FnZSIsInB1c2giLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJvblVzZXJTdGF0dXNDaGFuZ2UiLCJvbkNvbm5lY3Rpb25TdGF0dXMiLCJvblR5cGluZyIsIm9uVW5yZWFkTWVzc2FnZSIsInJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uIiwicmVxdWVzdFBlcm1pc3Npb24iLCJnZXRNZXNzYWdlcyIsImdldCIsIm1lc3NhZ2VzIiwiZ2V0VXNlcnMiLCJkb2N0b3JzIiwibWFwIiwiZG9jdG9yIiwic3VwYWJhc2VfaWQiLCJuYW1lIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUxIiwiZW1haWwiLCJzcGVjaWFsdHkiLCJzcGVjaWFsaXR5IiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImdldFVucmVhZENvdW50cyIsInVucmVhZF9jb3VudHMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImNoYXRTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatRealTime.ts\n"));

/***/ })

});