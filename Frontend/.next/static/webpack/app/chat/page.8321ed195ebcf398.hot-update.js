"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/services/chatRealTime.ts":
/*!**************************************!*\
  !*** ./src/services/chatRealTime.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: function() { return /* binding */ chatService; }\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n\n\nclass ChatService {\n    connect() {\n        // Si ya tenemos una promesa de conexión en curso, la retornamos\n        if (this.connectPromise) {\n            return this.connectPromise;\n        }\n        this.connectPromise = new Promise((resolve)=>{\n            var _this_socket;\n            if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n                resolve();\n                return;\n            }\n            if (this.isConnecting) {\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(this.baseUrl, {\n                withCredentials: true,\n                transports: [\n                    \"polling\",\n                    \"websocket\"\n                ],\n                timeout: 20000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                reconnectionDelay: 2000,\n                reconnectionDelayMax: 10000,\n                forceNew: false,\n                autoConnect: true,\n                upgrade: true,\n                rememberUpgrade: false\n            });\n            this.socket.on(\"connect\", ()=>{\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(true));\n                resolve();\n            });\n            this.socket.on(\"connect_error\", (error)=>{\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Solo intentar reconectar automáticamente en errores de red\n                if (error.message && !error.message.includes(\"xhr poll error\")) {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            this.socket.on(\"disconnect\", (reason)=>{\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Auto-reconectar solo si no fue una desconexión intencional\n                if (reason !== \"io client disconnect\" && reason !== \"io server disconnect\") {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            // Timeout más generoso para permitir la conexión\n            setTimeout(()=>{\n                var _this_socket;\n                this.isConnecting = false;\n                if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                    console.log(\"⚠️ Socket.IO connection timeout, falling back to HTTP\");\n                    this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                }\n                resolve();\n            }, 15000);\n            this.socket.on(\"new_message\", (message)=>{\n                console.log(\"\\uD83D\\uDCE8 New message received:\", message);\n                // Mostrar notificación de nuevo mensaje\n                this.showNotification(message);\n                this.messageCallbacks.forEach((callback)=>callback(message));\n            });\n            this.socket.on(\"message_sent\", (message)=>{\n                console.log(\"✅ Message sent confirmation:\", message);\n            });\n            this.socket.on(\"user_status\", (data)=>{\n                console.log(\"\\uD83D\\uDC64 User status change:\", data);\n                this.userStatusCallbacks.forEach((callback)=>callback(data.user_id, data.status));\n            });\n            this.socket.on(\"user_typing\", (data)=>{\n                console.log(\"⌨️ User typing:\", data);\n                this.typingCallbacks.forEach((callback)=>callback(data.user_id, data.is_typing));\n            });\n            this.socket.on(\"unread_message\", (data)=>{\n                console.log(\"\\uD83D\\uDD14 Unread message notification:\", data);\n                this.unreadMessageCallbacks.forEach((callback)=>callback(data));\n            });\n            this.socket.on(\"message_error\", (error)=>{\n                console.error(\"❌ Message error:\", error.error);\n            });\n        });\n        return this.connectPromise;\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n        setTimeout(()=>{\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                this.connectPromise = null; // Reset promise\n                this.connect();\n            }\n        }, delay);\n    }\n    showNotification(message) {\n        // Solo mostrar notificación si el usuario no está en la página del chat\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            if (document.hidden) {\n                new Notification(\"Nuevo mensaje de \".concat(message.sender_name), {\n                    body: message.message,\n                    icon: \"/favicon.ico\",\n                    tag: \"chat-message\"\n                });\n            }\n        }\n    }\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectPromise = null; // Reset promise\n        this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n    }\n    isSocketConnected() {\n        var _this_socket;\n        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;\n    }\n    sendMessage(receiverId, message) {\n        var _this_socket;\n        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n            this.sendMessageHttp(receiverId, message).catch((error)=>{\n                console.error(\"Error enviando mensaje por HTTP:\", error);\n            });\n            return;\n        }\n        this.socket.emit(\"send_message\", {\n            receiver_id: receiverId,\n            message: message\n        });\n    }\n    sendTypingIndicator(receiverId, isTyping) {\n        var _this_socket;\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            this.socket.emit(\"typing\", {\n                receiver_id: receiverId,\n                is_typing: isTyping\n            });\n        }\n    }\n    startTyping(receiverId) {\n        this.sendTypingIndicator(receiverId, true);\n        // Limpiar timer anterior si existe\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n        }\n        // Enviar \"stop typing\" después de 3 segundos\n        this.typingTimer = setTimeout(()=>{\n            this.sendTypingIndicator(receiverId, false);\n        }, 3000);\n    }\n    stopTyping(receiverId) {\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n            this.typingTimer = null;\n        }\n        this.sendTypingIndicator(receiverId, false);\n    }\n    async sendMessageHttp(receiverId, message) {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/send-message\", {\n                receiver_id: receiverId,\n                message: message\n            });\n            const messageData = {\n                id: response.data.id.toString(),\n                sender_id: response.data.sender_id.toString(),\n                receiver_id: response.data.receiver_id.toString(),\n                sender_name: \"T\\xfa\",\n                message: response.data.message,\n                timestamp: response.data.timestamp,\n                is_mine: true\n            };\n            // Notificar a los callbacks\n            this.messageCallbacks.forEach((callback)=>callback(messageData));\n            return messageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n    onMessage(callback) {\n        this.messageCallbacks.push(callback);\n        return ()=>{\n            const index = this.messageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.messageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUserStatusChange(callback) {\n        this.userStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.userStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.userStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onConnectionStatus(callback) {\n        this.connectionStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.connectionStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.connectionStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onTyping(callback) {\n        this.typingCallbacks.push(callback);\n        return ()=>{\n            const index = this.typingCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.typingCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUnreadMessage(callback) {\n        this.unreadMessageCallbacks.push(callback);\n        return ()=>{\n            const index = this.unreadMessageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.unreadMessageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    requestNotificationPermission() {\n        if (\"Notification\" in window && Notification.permission === \"default\") {\n            Notification.requestPermission();\n        }\n    }\n    async getMessages(receiverId) {\n        try {\n            // Usar la nueva ruta que maneja UUIDs\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-messages-uuid/\".concat(receiverId));\n            return response.data.messages || [];\n        } catch (error) {\n            throw error;\n        }\n    }\n    async getUsers() {\n        try {\n            var _data_doctors;\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-chat-doctors\");\n            const data = response.data;\n            return ((_data_doctors = data.doctors) === null || _data_doctors === void 0 ? void 0 : _data_doctors.map((doctor)=>({\n                    id: doctor.id.toString(),\n                    supabase_id: doctor.supabase_id,\n                    name: \"\".concat(doctor.firstName, \" \").concat(doctor.lastName1),\n                    email: doctor.email,\n                    specialty: doctor.speciality,\n                    status: \"offline\"\n                }))) || [];\n        } catch (error) {\n            return [\n                {\n                    id: \"1\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Juan P\\xe9rez\",\n                    email: \"juan.perez@hospital.com\",\n                    specialty: \"Cardiolog\\xeda\",\n                    status: \"online\"\n                },\n                {\n                    id: \"2\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dra. Mar\\xeda Gonz\\xe1lez\",\n                    email: \"maria.gonzalez@hospital.com\",\n                    specialty: \"Neurolog\\xeda\",\n                    status: \"offline\"\n                },\n                {\n                    id: \"3\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Carlos L\\xf3pez\",\n                    email: \"carlos.lopez@hospital.com\",\n                    specialty: \"Pediatr\\xeda\",\n                    status: \"offline\"\n                }\n            ];\n        }\n    }\n    async getUnreadCounts() {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-unread-counts\");\n            const data = response.data;\n            return data.unread_counts || {};\n        } catch (error) {\n            return {};\n        }\n    }\n    constructor(){\n        this.socket = null;\n        this.baseUrl = \"http://localhost:5000\" || 0;\n        this.messageCallbacks = [];\n        this.userStatusCallbacks = [];\n        this.connectionStatusCallbacks = [];\n        this.typingCallbacks = [];\n        this.unreadMessageCallbacks = [];\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.isConnecting = false;\n        this.typingTimer = null;\n        this.connectPromise = null;\n    }\n}\nconst chatService = new ChatService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0UmVhbFRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ2xCO0FBeUM1QixNQUFNRTtJQWNKQyxVQUF5QjtRQUN2QixnRUFBZ0U7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzdCO1lBQUosS0FBSSxtQkFBSSxDQUFDQyxNQUFNLGNBQVgsZ0RBQWFDLFNBQVMsRUFBRTtnQkFDMUJGO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ0csWUFBWSxFQUFFO2dCQUNyQkg7Z0JBQ0E7WUFDRjtZQUVBLElBQUksQ0FBQ0csWUFBWSxHQUFHO1lBRXBCLElBQUksQ0FBQ0YsTUFBTSxHQUFHUCxvREFBRUEsQ0FBQyxJQUFJLENBQUNVLE9BQU8sRUFBRTtnQkFDN0JDLGlCQUFpQjtnQkFDakJDLFlBQVk7b0JBQUM7b0JBQVc7aUJBQVk7Z0JBQ3BDQyxTQUFTO2dCQUNUQyxjQUFjO2dCQUNkQyxzQkFBc0I7Z0JBQ3RCQyxtQkFBbUI7Z0JBQ25CQyxzQkFBc0I7Z0JBQ3RCQyxVQUFVO2dCQUNWQyxhQUFhO2dCQUNiQyxTQUFTO2dCQUNUQyxpQkFBaUI7WUFDbkI7WUFFQSxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsRUFBRSxDQUFDLFdBQVc7Z0JBQ3hCLElBQUksQ0FBQ2IsWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNjLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLHlCQUF5QixDQUFDQyxPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7Z0JBQzVEcEI7WUFDRjtZQUVBLElBQUksQ0FBQ0MsTUFBTSxDQUFDZSxFQUFFLENBQUMsaUJBQWlCLENBQUNLO2dCQUMvQixJQUFJLENBQUNsQixZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FB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RDtRQUNIO0lBQ0Y7SUFFQSxNQUFNbUUsa0JBQXlEO1FBQzdELElBQUk7WUFDRixNQUFNbkMsV0FBVyxNQUFNdkUsZ0RBQUdBLENBQUMyRixHQUFHLENBQUM7WUFDL0IsTUFBTXZELE9BQU9tQyxTQUFTbkMsSUFBSTtZQUMxQixPQUFPQSxLQUFLdUUsYUFBYSxJQUFJLENBQUM7UUFDaEMsRUFBRSxPQUFPakYsT0FBTztZQUNkLE9BQU8sQ0FBQztRQUNWO0lBQ0Y7O2FBeldRcEIsU0FBd0I7YUFDeEJHLFVBQVVtRyx1QkFBK0IsSUFBSTthQUM3Q3pFLG1CQUFzQyxFQUFFO2FBQ3hDRSxzQkFBNEMsRUFBRTthQUM5Q2QsNEJBQXdELEVBQUU7YUFDMURpQixrQkFBb0MsRUFBRTthQUN0Q0UseUJBQWtELEVBQUU7YUFDcERwQixvQkFBb0I7YUFDcEJxQix1QkFBdUI7YUFDdkJuQyxlQUFlO2FBQ2Y0RCxjQUFxQzthQUNyQ2pFLGlCQUF1Qzs7QUErVmpEO0FBRU8sTUFBTTRHLGNBQWMsSUFBSTlHLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2NoYXRSZWFsVGltZS50cz80NzA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcclxuaW1wb3J0IGFwaSBmcm9tICdAL2xpYi9hcGknO1xyXG5cclxuaW50ZXJmYWNlIENoYXRNZXNzYWdlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHNlbmRlcl9pZDogc3RyaW5nO1xyXG4gIHJlY2VpdmVyX2lkPzogc3RyaW5nO1xyXG4gIHNlbmRlcl9uYW1lOiBzdHJpbmc7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIGlzX21pbmU6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBVc2VyIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHN1cGFiYXNlX2lkPzogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBlbWFpbD86IHN0cmluZztcclxuICBzcGVjaWFsdHk/OiBzdHJpbmc7XHJcbiAgc3RhdHVzOiAnb25saW5lJyB8ICdvZmZsaW5lJztcclxufVxyXG5cclxuaW50ZXJmYWNlIE1lc3NhZ2VDYWxsYmFjayB7XHJcbiAgKG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZXJTdGF0dXNDYWxsYmFjayB7XHJcbiAgKHVzZXJJZDogc3RyaW5nLCBzdGF0dXM6ICdvbmxpbmUnIHwgJ29mZmxpbmUnKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayB7XHJcbiAgKGNvbm5lY3RlZDogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUeXBpbmdDYWxsYmFjayB7XHJcbiAgKHVzZXJJZDogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBVbnJlYWRNZXNzYWdlQ2FsbGJhY2sge1xyXG4gIChkYXRhOiB7IHNlbmRlcl9pZDogc3RyaW5nOyBzZW5kZXJfbmFtZTogc3RyaW5nOyBtZXNzYWdlX3ByZXZpZXc6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmcgfSk6IHZvaWQ7XHJcbn1cclxuXHJcbmNsYXNzIENoYXRTZXJ2aWNlIHtcclxuICBwcml2YXRlIHNvY2tldDogU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAwJztcclxuICBwcml2YXRlIG1lc3NhZ2VDYWxsYmFja3M6IE1lc3NhZ2VDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSB1c2VyU3RhdHVzQ2FsbGJhY2tzOiBVc2VyU3RhdHVzQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrczogQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHR5cGluZ0NhbGxiYWNrczogVHlwaW5nQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgdW5yZWFkTWVzc2FnZUNhbGxiYWNrczogVW5yZWFkTWVzc2FnZUNhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICBwcml2YXRlIG1heFJlY29ubmVjdEF0dGVtcHRzID0gMztcclxuICBwcml2YXRlIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgdHlwaW5nVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBjb25uZWN0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICBjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gU2kgeWEgdGVuZW1vcyB1bmEgcHJvbWVzYSBkZSBjb25leGnDs24gZW4gY3Vyc28sIGxhIHJldG9ybmFtb3NcclxuICAgIGlmICh0aGlzLmNvbm5lY3RQcm9taXNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZykge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuc29ja2V0ID0gaW8odGhpcy5iYXNlVXJsLCB7XHJcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcG9ydHM6IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXSxcclxuICAgICAgICB0aW1lb3V0OiAyMDAwMCxcclxuICAgICAgICByZWNvbm5lY3Rpb246IHRydWUsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDMsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDIwMDAsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDEwMDAwLFxyXG4gICAgICAgIGZvcmNlTmV3OiBmYWxzZSxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgICB1cGdyYWRlOiB0cnVlLFxyXG4gICAgICAgIHJlbWVtYmVyVXBncmFkZTogZmFsc2VcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRydWUpKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZmFsc2UpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTb2xvIGludGVudGFyIHJlY29uZWN0YXIgYXV0b23DoXRpY2FtZW50ZSBlbiBlcnJvcmVzIGRlIHJlZFxyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmICFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd4aHIgcG9sbCBlcnJvcicpKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNvY2tldD8uY29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAyMDAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCAocmVhc29uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXV0by1yZWNvbmVjdGFyIHNvbG8gc2kgbm8gZnVlIHVuYSBkZXNjb25leGnDs24gaW50ZW5jaW9uYWxcclxuICAgICAgICBpZiAocmVhc29uICE9PSAnaW8gY2xpZW50IGRpc2Nvbm5lY3QnICYmIHJlYXNvbiAhPT0gJ2lvIHNlcnZlciBkaXNjb25uZWN0Jykge1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgMjAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFRpbWVvdXQgbcOhcyBnZW5lcm9zbyBwYXJhIHBlcm1pdGlyIGxhIGNvbmV4acOzblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBTb2NrZXQuSU8gY29ubmVjdGlvbiB0aW1lb3V0LCBmYWxsaW5nIGJhY2sgdG8gSFRUUCcpO1xyXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9LCAxNTAwMCk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignbmV3X21lc3NhZ2UnLCAobWVzc2FnZTogQ2hhdE1lc3NhZ2UpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TqCBOZXcgbWVzc2FnZSByZWNlaXZlZDonLCBtZXNzYWdlKTtcclxuICAgICAgICAvLyBNb3N0cmFyIG5vdGlmaWNhY2nDs24gZGUgbnVldm8gbWVuc2FqZVxyXG4gICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhtZXNzYWdlKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2Vfc2VudCcsIChtZXNzYWdlOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIE1lc3NhZ2Ugc2VudCBjb25maXJtYXRpb246JywgbWVzc2FnZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ3VzZXJfc3RhdHVzJywgKGRhdGE6IHsgdXNlcl9pZDogc3RyaW5nOyBzdGF0dXM6ICdvbmxpbmUnIHwgJ29mZmxpbmUnIH0pID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+RpCBVc2VyIHN0YXR1cyBjaGFuZ2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YS51c2VyX2lkLCBkYXRhLnN0YXR1cykpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCd1c2VyX3R5cGluZycsIChkYXRhOiB7IHVzZXJfaWQ6IHN0cmluZzsgaXNfdHlwaW5nOiBib29sZWFuIH0pID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4oyo77iPIFVzZXIgdHlwaW5nOicsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YS51c2VyX2lkLCBkYXRhLmlzX3R5cGluZykpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCd1bnJlYWRfbWVzc2FnZScsIChkYXRhOiB7IHNlbmRlcl9pZDogc3RyaW5nOyBzZW5kZXJfbmFtZTogc3RyaW5nOyBtZXNzYWdlX3ByZXZpZXc6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SUIFVucmVhZCBtZXNzYWdlIG5vdGlmaWNhdGlvbjonLCBkYXRhKTtcclxuICAgICAgICB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2VfZXJyb3InLCAoZXJyb3I6IHsgZXJyb3I6IHN0cmluZyB9KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE1lc3NhZ2UgZXJyb3I6JywgZXJyb3IuZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhdHRlbXB0UmVjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPj0gdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIDMwMDAwKTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLnNvY2tldD8uY29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBudWxsOyAvLyBSZXNldCBwcm9taXNlXHJcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGRlbGF5KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlOiBDaGF0TWVzc2FnZSk6IHZvaWQge1xyXG4gICAgLy8gU29sbyBtb3N0cmFyIG5vdGlmaWNhY2nDs24gc2kgZWwgdXN1YXJpbyBubyBlc3TDoSBlbiBsYSBww6FnaW5hIGRlbCBjaGF0XHJcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xyXG4gICAgICAgIG5ldyBOb3RpZmljYXRpb24oYE51ZXZvIG1lbnNhamUgZGUgJHttZXNzYWdlLnNlbmRlcl9uYW1lfWAsIHtcclxuICAgICAgICAgIGJvZHk6IG1lc3NhZ2UubWVzc2FnZSxcclxuICAgICAgICAgIGljb246ICcvZmF2aWNvbi5pY28nLFxyXG4gICAgICAgICAgdGFnOiAnY2hhdC1tZXNzYWdlJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XHJcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5zb2NrZXQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IHByb21pc2VcclxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgfVxyXG5cclxuICBpc1NvY2tldENvbm5lY3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnNvY2tldD8uY29ubmVjdGVkIHx8IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2VuZE1lc3NhZ2UocmVjZWl2ZXJJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICB0aGlzLnNlbmRNZXNzYWdlSHR0cChyZWNlaXZlcklkLCBtZXNzYWdlKS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW52aWFuZG8gbWVuc2FqZSBwb3IgSFRUUDonLCBlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb2NrZXQuZW1pdCgnc2VuZF9tZXNzYWdlJywge1xyXG4gICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzZW5kVHlwaW5nSW5kaWNhdG9yKHJlY2VpdmVySWQ6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnNvY2tldD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ3R5cGluZycsIHtcclxuICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgICBpc190eXBpbmc6IGlzVHlwaW5nXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhcnRUeXBpbmcocmVjZWl2ZXJJZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZCwgdHJ1ZSk7XHJcbiAgICBcclxuICAgIC8vIExpbXBpYXIgdGltZXIgYW50ZXJpb3Igc2kgZXhpc3RlXHJcbiAgICBpZiAodGhpcy50eXBpbmdUaW1lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50eXBpbmdUaW1lcik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEVudmlhciBcInN0b3AgdHlwaW5nXCIgZGVzcHXDqXMgZGUgMyBzZWd1bmRvc1xyXG4gICAgdGhpcy50eXBpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZCwgZmFsc2UpO1xyXG4gICAgfSwgMzAwMCk7XHJcbiAgfVxyXG5cclxuICBzdG9wVHlwaW5nKHJlY2VpdmVySWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMudHlwaW5nVGltZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHlwaW5nVGltZXIpO1xyXG4gICAgICB0aGlzLnR5cGluZ1RpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuc2VuZFR5cGluZ0luZGljYXRvcihyZWNlaXZlcklkLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kTWVzc2FnZUh0dHAocmVjZWl2ZXJJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPENoYXRNZXNzYWdlPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvc2VuZC1tZXNzYWdlJywge1xyXG4gICAgICAgIHJlY2VpdmVyX2lkOiByZWNlaXZlcklkLFxyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YTogQ2hhdE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmRhdGEuaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBzZW5kZXJfaWQ6IHJlc3BvbnNlLmRhdGEuc2VuZGVyX2lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgcmVjZWl2ZXJfaWQ6IHJlc3BvbnNlLmRhdGEucmVjZWl2ZXJfaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBzZW5kZXJfbmFtZTogJ1TDuicsXHJcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZGF0YS5tZXNzYWdlLFxyXG4gICAgICAgIHRpbWVzdGFtcDogcmVzcG9uc2UuZGF0YS50aW1lc3RhbXAsXHJcbiAgICAgICAgaXNfbWluZTogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gTm90aWZpY2FyIGEgbG9zIGNhbGxiYWNrc1xyXG4gICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhtZXNzYWdlRGF0YSkpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG1lc3NhZ2VEYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lc3NhZ2UoY2FsbGJhY2s6IE1lc3NhZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZUNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9uVXNlclN0YXR1c0NoYW5nZShjYWxsYmFjazogVXNlclN0YXR1c0NhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLnVzZXJTdGF0dXNDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb25Db25uZWN0aW9uU3RhdHVzKGNhbGxiYWNrOiBDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvblR5cGluZyhjYWxsYmFjazogVHlwaW5nQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMudHlwaW5nQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMudHlwaW5nQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvblVucmVhZE1lc3NhZ2UoY2FsbGJhY2s6IFVucmVhZE1lc3NhZ2VDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5yZWFkTWVzc2FnZUNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlcXVlc3ROb3RpZmljYXRpb25QZXJtaXNzaW9uKCk6IHZvaWQge1xyXG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdyAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0TWVzc2FnZXMocmVjZWl2ZXJJZDogc3RyaW5nKTogUHJvbWlzZTxDaGF0TWVzc2FnZVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVc2FyIGxhIG51ZXZhIHJ1dGEgcXVlIG1hbmVqYSBVVUlEc1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoYC9nZXQtbWVzc2FnZXMtdXVpZC8ke3JlY2VpdmVySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1lc3NhZ2VzIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VycygpOiBQcm9taXNlPFVzZXJbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvZ2V0LWNoYXQtZG9jdG9ycycpO1xyXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgcmV0dXJuIGRhdGEuZG9jdG9ycz8ubWFwKChkb2N0b3I6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogZG9jdG9yLmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc3VwYWJhc2VfaWQ6IGRvY3Rvci5zdXBhYmFzZV9pZCxcclxuICAgICAgICBuYW1lOiBgJHtkb2N0b3IuZmlyc3ROYW1lfSAke2RvY3Rvci5sYXN0TmFtZTF9YCxcclxuICAgICAgICBlbWFpbDogZG9jdG9yLmVtYWlsLFxyXG4gICAgICAgIHNwZWNpYWx0eTogZG9jdG9yLnNwZWNpYWxpdHksXHJcbiAgICAgICAgc3RhdHVzOiAnb2ZmbGluZScgYXMgY29uc3RcclxuICAgICAgfSkpIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJzEnLFxyXG4gICAgICAgICAgc3VwYWJhc2VfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksICAvLyBHZW5lcmFyIFVVSUQgcmVhbFxyXG4gICAgICAgICAgbmFtZTogJ0RyLiBKdWFuIFDDqXJleicsXHJcbiAgICAgICAgICBlbWFpbDogJ2p1YW4ucGVyZXpAaG9zcGl0YWwuY29tJyxcclxuICAgICAgICAgIHNwZWNpYWx0eTogJ0NhcmRpb2xvZ8OtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvbmxpbmUnIGFzIGNvbnN0XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJzInLFxyXG4gICAgICAgICAgc3VwYWJhc2VfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksICAvLyBHZW5lcmFyIFVVSUQgcmVhbFxyXG4gICAgICAgICAgbmFtZTogJ0RyYS4gTWFyw61hIEdvbnrDoWxleicsXHJcbiAgICAgICAgICBlbWFpbDogJ21hcmlhLmdvbnphbGV6QGhvc3BpdGFsLmNvbScsXHJcbiAgICAgICAgICBzcGVjaWFsdHk6ICdOZXVyb2xvZ8OtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvZmZsaW5lJyBhcyBjb25zdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICczJyxcclxuICAgICAgICAgIHN1cGFiYXNlX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLCAgLy8gR2VuZXJhciBVVUlEIHJlYWxcclxuICAgICAgICAgIG5hbWU6ICdEci4gQ2FybG9zIEzDs3BleicsXHJcbiAgICAgICAgICBlbWFpbDogJ2Nhcmxvcy5sb3BlekBob3NwaXRhbC5jb20nLFxyXG4gICAgICAgICAgc3BlY2lhbHR5OiAnUGVkaWF0csOtYScsXHJcbiAgICAgICAgICBzdGF0dXM6ICdvZmZsaW5lJyBhcyBjb25zdFxyXG4gICAgICAgIH1cclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVucmVhZENvdW50cygpOiBQcm9taXNlPHsgW3VzZXJJZDogc3RyaW5nXTogbnVtYmVyIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2dldC11bnJlYWQtY291bnRzJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICByZXR1cm4gZGF0YS51bnJlYWRfY291bnRzIHx8IHt9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNoYXRTZXJ2aWNlID0gbmV3IENoYXRTZXJ2aWNlKCk7XHJcbmV4cG9ydCB0eXBlIHsgQ2hhdE1lc3NhZ2UsIFVzZXIsIENvbm5lY3Rpb25TdGF0dXNDYWxsYmFjaywgVHlwaW5nQ2FsbGJhY2ssIFVucmVhZE1lc3NhZ2VDYWxsYmFjayB9O1xyXG4iXSwibmFtZXMiOlsiaW8iLCJhcGkiLCJDaGF0U2VydmljZSIsImNvbm5lY3QiLCJjb25uZWN0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic29ja2V0IiwiY29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiYmFzZVVybCIsIndpdGhDcmVkZW50aWFscyIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0IiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwiZm9yY2VOZXciLCJhdXRvQ29ubmVjdCIsInVwZ3JhZGUiLCJyZW1lbWJlclVwZ3JhZGUiLCJvbiIsInJlY29ubmVjdEF0dGVtcHRzIiwiY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcyIsImZvckVhY2giLCJjYWxsYmFjayIsImVycm9yIiwibWVzc2FnZSIsImluY2x1ZGVzIiwic2V0VGltZW91dCIsImF0dGVtcHRSZWNvbm5lY3QiLCJyZWFzb24iLCJjb25zb2xlIiwibG9nIiwic2hvd05vdGlmaWNhdGlvbiIsIm1lc3NhZ2VDYWxsYmFja3MiLCJkYXRhIiwidXNlclN0YXR1c0NhbGxiYWNrcyIsInVzZXJfaWQiLCJzdGF0dXMiLCJ0eXBpbmdDYWxsYmFja3MiLCJpc190eXBpbmciLCJ1bnJlYWRNZXNzYWdlQ2FsbGJhY2tzIiwibWF4UmVjb25uZWN0QXR0ZW1wdHMiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJ3aW5kb3ciLCJOb3RpZmljYXRpb24iLCJwZXJtaXNzaW9uIiwiZG9jdW1lbnQiLCJoaWRkZW4iLCJzZW5kZXJfbmFtZSIsImJvZHkiLCJpY29uIiwidGFnIiwiZGlzY29ubmVjdCIsImlzU29ja2V0Q29ubmVjdGVkIiwic2VuZE1lc3NhZ2UiLCJyZWNlaXZlcklkIiwic2VuZE1lc3NhZ2VIdHRwIiwiY2F0Y2giLCJlbWl0IiwicmVjZWl2ZXJfaWQiLCJzZW5kVHlwaW5nSW5kaWNhdG9yIiwiaXNUeXBpbmciLCJzdGFydFR5cGluZyIsInR5cGluZ1RpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic3RvcFR5cGluZyIsInJlc3BvbnNlIiwicG9zdCIsIm1lc3NhZ2VEYXRhIiwiaWQiLCJ0b1N0cmluZyIsInNlbmRlcl9pZCIsInRpbWVzdGFtcCIsImlzX21pbmUiLCJvbk1lc3NhZ2UiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwib25Vc2VyU3RhdHVzQ2hhbmdlIiwib25Db25uZWN0aW9uU3RhdHVzIiwib25UeXBpbmciLCJvblVucmVhZE1lc3NhZ2UiLCJyZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbiIsInJlcXVlc3RQZXJtaXNzaW9uIiwiZ2V0TWVzc2FnZXMiLCJnZXQiLCJtZXNzYWdlcyIsImdldFVzZXJzIiwiZG9jdG9ycyIsIm1hcCIsImRvY3RvciIsInN1cGFiYXNlX2lkIiwibmFtZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lMSIsImVtYWlsIiwic3BlY2lhbHR5Iiwic3BlY2lhbGl0eSIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJnZXRVbnJlYWRDb3VudHMiLCJ1bnJlYWRfY291bnRzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJjaGF0U2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatRealTime.ts\n"));

/***/ })

});