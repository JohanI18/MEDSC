"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/services/chatRealTime.ts":
/*!**************************************!*\
  !*** ./src/services/chatRealTime.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatService: function() { return /* binding */ chatService; }\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n\n\nclass ChatService {\n    connect() {\n        // Si ya tenemos una promesa de conexión en curso, la retornamos\n        if (this.connectPromise) {\n            return this.connectPromise;\n        }\n        this.connectPromise = new Promise((resolve)=>{\n            var _this_socket;\n            if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n                console.log(\"Socket already connected\");\n                resolve();\n                return;\n            }\n            if (this.isConnecting) {\n                console.log(\"Already connecting...\");\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            console.log(\"Attempting to connect to Socket.IO server...\");\n            this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(this.baseUrl, {\n                withCredentials: true,\n                transports: [\n                    \"polling\",\n                    \"websocket\"\n                ],\n                timeout: 20000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                reconnectionDelay: 2000,\n                reconnectionDelayMax: 10000,\n                forceNew: false,\n                autoConnect: true,\n                upgrade: true,\n                rememberUpgrade: false\n            });\n            this.socket.on(\"connect\", ()=>{\n                console.log(\"✅ Socket.IO connected successfully\");\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(true));\n                resolve();\n            });\n            this.socket.on(\"connect_error\", (error)=>{\n                console.error(\"❌ Socket.IO connection error:\", error);\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Solo intentar reconectar automáticamente en errores de red\n                if (error.message && !error.message.includes(\"xhr poll error\")) {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            this.socket.on(\"disconnect\", (reason)=>{\n                console.log(\"\\uD83D\\uDD0C Socket.IO disconnected:\", reason);\n                this.isConnecting = false;\n                this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                // Auto-reconectar solo si no fue una desconexión intencional\n                if (reason !== \"io client disconnect\" && reason !== \"io server disconnect\") {\n                    setTimeout(()=>{\n                        var _this_socket;\n                        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                            this.attemptReconnect();\n                        }\n                    }, 2000);\n                }\n            });\n            // Timeout más generoso para permitir la conexión\n            setTimeout(()=>{\n                var _this_socket;\n                this.isConnecting = false;\n                if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n                    console.log(\"⚠️ Socket.IO connection timeout, falling back to HTTP\");\n                    this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n                }\n                resolve();\n            }, 15000);\n            this.socket.on(\"new_message\", (message)=>{\n                console.log(\"\\uD83D\\uDCE8 New message received:\", message);\n                // Mostrar notificación de nuevo mensaje\n                this.showNotification(message);\n                this.messageCallbacks.forEach((callback)=>callback(message));\n            });\n            this.socket.on(\"message_sent\", (message)=>{\n                console.log(\"✅ Message sent confirmation:\", message);\n            });\n            this.socket.on(\"user_status\", (data)=>{\n                console.log(\"\\uD83D\\uDC64 User status change:\", data);\n                this.userStatusCallbacks.forEach((callback)=>callback(data.user_id, data.status));\n            });\n            this.socket.on(\"user_typing\", (data)=>{\n                console.log(\"⌨️ User typing:\", data);\n                this.typingCallbacks.forEach((callback)=>callback(data.user_id, data.is_typing));\n            });\n            this.socket.on(\"unread_message\", (data)=>{\n                console.log(\"\\uD83D\\uDD14 Unread message notification:\", data);\n                this.unreadMessageCallbacks.forEach((callback)=>callback(data));\n            });\n            this.socket.on(\"message_error\", (error)=>{\n                console.error(\"❌ Message error:\", error.error);\n            });\n        });\n        return this.connectPromise;\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n        setTimeout(()=>{\n            var _this_socket;\n            if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) && !this.isConnecting) {\n                this.connectPromise = null; // Reset promise\n                this.connect();\n            }\n        }, delay);\n    }\n    showNotification(message) {\n        // Solo mostrar notificación si el usuario no está en la página del chat\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            if (document.hidden) {\n                new Notification(\"Nuevo mensaje de \".concat(message.sender_name), {\n                    body: message.message,\n                    icon: \"/favicon.ico\",\n                    tag: \"chat-message\"\n                });\n            }\n        }\n    }\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectPromise = null; // Reset promise\n        this.connectionStatusCallbacks.forEach((callback)=>callback(false));\n    }\n    isSocketConnected() {\n        var _this_socket;\n        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;\n    }\n    sendMessage(receiverId, message) {\n        var _this_socket;\n        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {\n            this.sendMessageHttp(receiverId, message).catch((error)=>{\n                console.error(\"Error enviando mensaje por HTTP:\", error);\n            });\n            return;\n        }\n        this.socket.emit(\"send_message\", {\n            receiver_id: receiverId,\n            message: message\n        });\n    }\n    sendTypingIndicator(receiverId, isTyping) {\n        var _this_socket;\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            this.socket.emit(\"typing\", {\n                receiver_id: receiverId,\n                is_typing: isTyping\n            });\n        }\n    }\n    startTyping(receiverId) {\n        this.sendTypingIndicator(receiverId, true);\n        // Limpiar timer anterior si existe\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n        }\n        // Enviar \"stop typing\" después de 3 segundos\n        this.typingTimer = setTimeout(()=>{\n            this.sendTypingIndicator(receiverId, false);\n        }, 3000);\n    }\n    stopTyping(receiverId) {\n        if (this.typingTimer) {\n            clearTimeout(this.typingTimer);\n            this.typingTimer = null;\n        }\n        this.sendTypingIndicator(receiverId, false);\n    }\n    async sendMessageHttp(receiverId, message) {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/send-message\", {\n                receiver_id: receiverId,\n                message: message\n            });\n            const messageData = {\n                id: response.data.id.toString(),\n                sender_id: response.data.sender_id.toString(),\n                receiver_id: response.data.receiver_id.toString(),\n                sender_name: \"T\\xfa\",\n                message: response.data.message,\n                timestamp: response.data.timestamp,\n                is_mine: true\n            };\n            // Notificar a los callbacks\n            this.messageCallbacks.forEach((callback)=>callback(messageData));\n            return messageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n    onMessage(callback) {\n        this.messageCallbacks.push(callback);\n        return ()=>{\n            const index = this.messageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.messageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUserStatusChange(callback) {\n        this.userStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.userStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.userStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onConnectionStatus(callback) {\n        this.connectionStatusCallbacks.push(callback);\n        return ()=>{\n            const index = this.connectionStatusCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.connectionStatusCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onTyping(callback) {\n        this.typingCallbacks.push(callback);\n        return ()=>{\n            const index = this.typingCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.typingCallbacks.splice(index, 1);\n            }\n        };\n    }\n    onUnreadMessage(callback) {\n        this.unreadMessageCallbacks.push(callback);\n        return ()=>{\n            const index = this.unreadMessageCallbacks.indexOf(callback);\n            if (index > -1) {\n                this.unreadMessageCallbacks.splice(index, 1);\n            }\n        };\n    }\n    requestNotificationPermission() {\n        if (\"Notification\" in window && Notification.permission === \"default\") {\n            Notification.requestPermission();\n        }\n    }\n    async getMessages(receiverId) {\n        try {\n            // Usar la nueva ruta que maneja UUIDs\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-messages-uuid/\".concat(receiverId));\n            return response.data.messages || [];\n        } catch (error) {\n            throw error;\n        }\n    }\n    async getUsers() {\n        try {\n            var _data_doctors;\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-chat-doctors\");\n            const data = response.data;\n            return ((_data_doctors = data.doctors) === null || _data_doctors === void 0 ? void 0 : _data_doctors.map((doctor)=>({\n                    id: doctor.id.toString(),\n                    supabase_id: doctor.supabase_id,\n                    name: \"\".concat(doctor.firstName, \" \").concat(doctor.lastName1),\n                    email: doctor.email,\n                    specialty: doctor.speciality,\n                    status: \"offline\"\n                }))) || [];\n        } catch (error) {\n            return [\n                {\n                    id: \"1\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Juan P\\xe9rez\",\n                    email: \"juan.perez@hospital.com\",\n                    specialty: \"Cardiolog\\xeda\",\n                    status: \"online\"\n                },\n                {\n                    id: \"2\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dra. Mar\\xeda Gonz\\xe1lez\",\n                    email: \"maria.gonzalez@hospital.com\",\n                    specialty: \"Neurolog\\xeda\",\n                    status: \"offline\"\n                },\n                {\n                    id: \"3\",\n                    supabase_id: crypto.randomUUID(),\n                    name: \"Dr. Carlos L\\xf3pez\",\n                    email: \"carlos.lopez@hospital.com\",\n                    specialty: \"Pediatr\\xeda\",\n                    status: \"offline\"\n                }\n            ];\n        }\n    }\n    async getUnreadCounts() {\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(\"/get-unread-counts\");\n            const data = response.data;\n            return data.unread_counts || {};\n        } catch (error) {\n            return {};\n        }\n    }\n    constructor(){\n        this.socket = null;\n        this.baseUrl = \"http://localhost:5000\" || 0;\n        this.messageCallbacks = [];\n        this.userStatusCallbacks = [];\n        this.connectionStatusCallbacks = [];\n        this.typingCallbacks = [];\n        this.unreadMessageCallbacks = [];\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.isConnecting = false;\n        this.typingTimer = null;\n        this.connectPromise = null;\n    }\n}\nconst chatService = new ChatService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0UmVhbFRpbWUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ2xCO0FBeUM1QixNQUFNRTtJQWNKQyxVQUF5QjtRQUN2QixnRUFBZ0U7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QjtRQUVBLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUlDLFFBQVEsQ0FBQ0M7Z0JBQzdCO1lBQUosS0FBSSxtQkFBSSxDQUFDQyxNQUFNLGNBQVgsZ0RBQWFDLFNBQVMsRUFBRTtnQkFDMUJDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWko7Z0JBQ0E7WUFDRjtZQUVBLElBQUksSUFBSSxDQUFDSyxZQUFZLEVBQUU7Z0JBQ3JCRixRQUFRQyxHQUFHLENBQUM7Z0JBQ1pKO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJLENBQUNLLFlBQVksR0FBRztZQUNwQkYsUUFBUUMsR0FBRyxDQUFDO1lBRVosSUFBSSxDQUFDSCxNQUFNLEdBQUdQLG9EQUFFQSxDQUFDLElBQUksQ0FBQ1ksT0FBTyxFQUFFO2dCQUM3QkMsaUJBQWlCO2dCQUNqQkMsWUFBWTtvQkFBQztvQkFBVztpQkFBWTtnQkFDcENDLFNBQVM7Z0JBQ1RDLGNBQWM7Z0JBQ2RDLHNCQUFzQjtnQkFDdEJDLG1CQUFtQjtnQkFDbkJDLHNCQUFzQjtnQkFDdEJDLFVBQVU7Z0JBQ1ZDLGFBQWE7Z0JBQ2JDLFNBQVM7Z0JBQ1RDLGlCQUFpQjtZQUNuQjtZQUVBLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ2lCLEVBQUUsQ0FBQyxXQUFXO2dCQUN4QmYsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ0MsWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNjLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLHlCQUF5QixDQUFDQyxPQUFPLENBQUNDLENBQUFBLFdBQVlBLFNBQVM7Z0JBQzVEdEI7WUFDRjtZ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Q0p1QixhQUFhTyxPQUFPQyxVQUFVO29CQUM5QlAsTUFBTTtvQkFDTkcsT0FBTztvQkFDUEMsV0FBVztvQkFDWC9ELFFBQVE7Z0JBQ1Y7Z0JBQ0E7b0JBQ0VtQyxJQUFJO29CQUNKdUIsYUFBYU8sT0FBT0MsVUFBVTtvQkFDOUJQLE1BQU07b0JBQ05HLE9BQU87b0JBQ1BDLFdBQVc7b0JBQ1gvRCxRQUFRO2dCQUNWO2FBQ0Q7UUFDSDtJQUNGO0lBRUEsTUFBTW1FLGtCQUF5RDtRQUM3RCxJQUFJO1lBQ0YsTUFBTW5DLFdBQVcsTUFBTXZFLGdEQUFHQSxDQUFDMkYsR0FBRyxDQUFDO1lBQy9CLE1BQU12RCxPQUFPbUMsU0FBU25DLElBQUk7WUFDMUIsT0FBT0EsS0FBS3VFLGFBQWEsSUFBSSxDQUFDO1FBQ2hDLEVBQUUsT0FBTy9FLE9BQU87WUFDZCxPQUFPLENBQUM7UUFDVjtJQUNGOzthQS9XUXRCLFNBQXdCO2FBQ3hCSyxVQUFVaUcsdUJBQStCLElBQUk7YUFDN0N6RSxtQkFBc0MsRUFBRTthQUN4Q0Usc0JBQTRDLEVBQUU7YUFDOUNaLDRCQUF3RCxFQUFFO2FBQzFEZSxrQkFBb0MsRUFBRTthQUN0Q0UseUJBQWtELEVBQUU7YUFDcERsQixvQkFBb0I7YUFDcEJtQix1QkFBdUI7YUFDdkJqQyxlQUFlO2FBQ2YwRCxjQUFxQzthQUNyQ2pFLGlCQUF1Qzs7QUFxV2pEO0FBRU8sTUFBTTRHLGNBQWMsSUFBSTlHLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2NoYXRSZWFsVGltZS50cz80NzA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcclxuaW1wb3J0IGFwaSBmcm9tICdAL2xpYi9hcGknO1xyXG5cclxuaW50ZXJmYWNlIENoYXRNZXNzYWdlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHNlbmRlcl9pZDogc3RyaW5nO1xyXG4gIHJlY2VpdmVyX2lkPzogc3RyaW5nO1xyXG4gIHNlbmRlcl9uYW1lOiBzdHJpbmc7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIGlzX21pbmU6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBVc2VyIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHN1cGFiYXNlX2lkPzogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBlbWFpbD86IHN0cmluZztcclxuICBzcGVjaWFsdHk/OiBzdHJpbmc7XHJcbiAgc3RhdHVzOiAnb25saW5lJyB8ICdvZmZsaW5lJztcclxufVxyXG5cclxuaW50ZXJmYWNlIE1lc3NhZ2VDYWxsYmFjayB7XHJcbiAgKG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZXJTdGF0dXNDYWxsYmFjayB7XHJcbiAgKHVzZXJJZDogc3RyaW5nLCBzdGF0dXM6ICdvbmxpbmUnIHwgJ29mZmxpbmUnKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayB7XHJcbiAgKGNvbm5lY3RlZDogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUeXBpbmdDYWxsYmFjayB7XHJcbiAgKHVzZXJJZDogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBVbnJlYWRNZXNzYWdlQ2FsbGJhY2sge1xyXG4gIChkYXRhOiB7IHNlbmRlcl9pZDogc3RyaW5nOyBzZW5kZXJfbmFtZTogc3RyaW5nOyBtZXNzYWdlX3ByZXZpZXc6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmcgfSk6IHZvaWQ7XHJcbn1cclxuXHJcbmNsYXNzIENoYXRTZXJ2aWNlIHtcclxuICBwcml2YXRlIHNvY2tldDogU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAwJztcclxuICBwcml2YXRlIG1lc3NhZ2VDYWxsYmFja3M6IE1lc3NhZ2VDYWxsYmFja1tdID0gW107XHJcbiAgcHJpdmF0ZSB1c2VyU3RhdHVzQ2FsbGJhY2tzOiBVc2VyU3RhdHVzQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrczogQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHR5cGluZ0NhbGxiYWNrczogVHlwaW5nQ2FsbGJhY2tbXSA9IFtdO1xyXG4gIHByaXZhdGUgdW5yZWFkTWVzc2FnZUNhbGxiYWNrczogVW5yZWFkTWVzc2FnZUNhbGxiYWNrW10gPSBbXTtcclxuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICBwcml2YXRlIG1heFJlY29ubmVjdEF0dGVtcHRzID0gMztcclxuICBwcml2YXRlIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgdHlwaW5nVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBjb25uZWN0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICBjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gU2kgeWEgdGVuZW1vcyB1bmEgcHJvbWVzYSBkZSBjb25leGnDs24gZW4gY3Vyc28sIGxhIHJldG9ybmFtb3NcclxuICAgIGlmICh0aGlzLmNvbm5lY3RQcm9taXNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWQnKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQWxyZWFkeSBjb25uZWN0aW5nLi4uJyk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlO1xyXG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIFNvY2tldC5JTyBzZXJ2ZXIuLi4nKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuc29ja2V0ID0gaW8odGhpcy5iYXNlVXJsLCB7XHJcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxyXG4gICAgICAgIHRyYW5zcG9ydHM6IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXSxcclxuICAgICAgICB0aW1lb3V0OiAyMDAwMCxcclxuICAgICAgICByZWNvbm5lY3Rpb246IHRydWUsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDMsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDIwMDAsXHJcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDEwMDAwLFxyXG4gICAgICAgIGZvcmNlTmV3OiBmYWxzZSxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgICB1cGdyYWRlOiB0cnVlLFxyXG4gICAgICAgIHJlbWVtYmVyVXBncmFkZTogZmFsc2VcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNvY2tldC5JTyBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0cnVlKSk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU29ja2V0LklPIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZmFsc2UpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTb2xvIGludGVudGFyIHJlY29uZWN0YXIgYXV0b23DoXRpY2FtZW50ZSBlbiBlcnJvcmVzIGRlIHJlZFxyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmICFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd4aHIgcG9sbCBlcnJvcicpKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNvY2tldD8uY29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAyMDAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCAocmVhc29uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjCBTb2NrZXQuSU8gZGlzY29ubmVjdGVkOicsIHJlYXNvbik7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhmYWxzZSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEF1dG8tcmVjb25lY3RhciBzb2xvIHNpIG5vIGZ1ZSB1bmEgZGVzY29uZXhpw7NuIGludGVuY2lvbmFsXHJcbiAgICAgICAgaWYgKHJlYXNvbiAhPT0gJ2lvIGNsaWVudCBkaXNjb25uZWN0JyAmJiByZWFzb24gIT09ICdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDIwMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBUaW1lb3V0IG3DoXMgZ2VuZXJvc28gcGFyYSBwZXJtaXRpciBsYSBjb25leGnDs25cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gU29ja2V0LklPIGNvbm5lY3Rpb24gdGltZW91dCwgZmFsbGluZyBiYWNrIHRvIEhUVFAnKTtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSwgMTUwMDApO1xyXG5cclxuICAgICAgdGhpcy5zb2NrZXQub24oJ25ld19tZXNzYWdlJywgKG1lc3NhZ2U6IENoYXRNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6ggTmV3IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgbWVzc2FnZSk7XHJcbiAgICAgICAgLy8gTW9zdHJhciBub3RpZmljYWNpw7NuIGRlIG51ZXZvIG1lbnNhamVcclxuICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24obWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sobWVzc2FnZSkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlX3NlbnQnLCAobWVzc2FnZTogYW55KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBNZXNzYWdlIHNlbnQgY29uZmlybWF0aW9uOicsIG1lc3NhZ2UpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCd1c2VyX3N0YXR1cycsIChkYXRhOiB7IHVzZXJfaWQ6IHN0cmluZzsgc3RhdHVzOiAnb25saW5lJyB8ICdvZmZsaW5lJyB9KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CfkaQgVXNlciBzdGF0dXMgY2hhbmdlOicsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEudXNlcl9pZCwgZGF0YS5zdGF0dXMpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbigndXNlcl90eXBpbmcnLCAoZGF0YTogeyB1c2VyX2lkOiBzdHJpbmc7IGlzX3R5cGluZzogYm9vbGVhbiB9KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KMqO+4jyBVc2VyIHR5cGluZzonLCBkYXRhKTtcclxuICAgICAgICB0aGlzLnR5cGluZ0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEudXNlcl9pZCwgZGF0YS5pc190eXBpbmcpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnNvY2tldC5vbigndW5yZWFkX21lc3NhZ2UnLCAoZGF0YTogeyBzZW5kZXJfaWQ6IHN0cmluZzsgc2VuZGVyX25hbWU6IHN0cmluZzsgbWVzc2FnZV9wcmV2aWV3OiBzdHJpbmc7IHRpbWVzdGFtcDogc3RyaW5nIH0pID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UlCBVbnJlYWQgbWVzc2FnZSBub3RpZmljYXRpb246JywgZGF0YSk7XHJcbiAgICAgICAgdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YSkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlX2Vycm9yJywgKGVycm9yOiB7IGVycm9yOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNZXNzYWdlIGVycm9yOicsIGVycm9yLmVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0UHJvbWlzZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXR0ZW1wdFJlY29ubmVjdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID49IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcclxuICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oMTAwMCAqIE1hdGgucG93KDIsIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCAzMDAwMCk7XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDsgLy8gUmVzZXQgcHJvbWlzZVxyXG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgICB9XHJcbiAgICB9LCBkZWxheSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNob3dOb3RpZmljYXRpb24obWVzc2FnZTogQ2hhdE1lc3NhZ2UpOiB2b2lkIHtcclxuICAgIC8vIFNvbG8gbW9zdHJhciBub3RpZmljYWNpw7NuIHNpIGVsIHVzdWFyaW8gbm8gZXN0w6EgZW4gbGEgcMOhZ2luYSBkZWwgY2hhdFxyXG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdyAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2dyYW50ZWQnKSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcclxuICAgICAgICBuZXcgTm90aWZpY2F0aW9uKGBOdWV2byBtZW5zYWplIGRlICR7bWVzc2FnZS5zZW5kZXJfbmFtZX1gLCB7XHJcbiAgICAgICAgICBib2R5OiBtZXNzYWdlLm1lc3NhZ2UsXHJcbiAgICAgICAgICBpY29uOiAnL2Zhdmljb24uaWNvJyxcclxuICAgICAgICAgIHRhZzogJ2NoYXQtbWVzc2FnZSdcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnNvY2tldCkge1xyXG4gICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBudWxsOyAvLyBSZXNldCBwcm9taXNlXHJcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhmYWxzZSkpO1xyXG4gIH1cclxuXHJcbiAgaXNTb2NrZXRDb25uZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCB8fCBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNlbmRNZXNzYWdlKHJlY2VpdmVySWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuc29ja2V0Py5jb25uZWN0ZWQpIHtcclxuICAgICAgdGhpcy5zZW5kTWVzc2FnZUh0dHAocmVjZWl2ZXJJZCwgbWVzc2FnZSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVudmlhbmRvIG1lbnNhamUgcG9yIEhUVFA6JywgZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc29ja2V0LmVtaXQoJ3NlbmRfbWVzc2FnZScsIHtcclxuICAgICAgcmVjZWl2ZXJfaWQ6IHJlY2VpdmVySWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VuZFR5cGluZ0luZGljYXRvcihyZWNlaXZlcklkOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCd0eXBpbmcnLCB7XHJcbiAgICAgICAgcmVjZWl2ZXJfaWQ6IHJlY2VpdmVySWQsXHJcbiAgICAgICAgaXNfdHlwaW5nOiBpc1R5cGluZ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXJ0VHlwaW5nKHJlY2VpdmVySWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5zZW5kVHlwaW5nSW5kaWNhdG9yKHJlY2VpdmVySWQsIHRydWUpO1xyXG4gICAgXHJcbiAgICAvLyBMaW1waWFyIHRpbWVyIGFudGVyaW9yIHNpIGV4aXN0ZVxyXG4gICAgaWYgKHRoaXMudHlwaW5nVGltZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHlwaW5nVGltZXIpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFbnZpYXIgXCJzdG9wIHR5cGluZ1wiIGRlc3B1w6lzIGRlIDMgc2VndW5kb3NcclxuICAgIHRoaXMudHlwaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5zZW5kVHlwaW5nSW5kaWNhdG9yKHJlY2VpdmVySWQsIGZhbHNlKTtcclxuICAgIH0sIDMwMDApO1xyXG4gIH1cclxuXHJcbiAgc3RvcFR5cGluZyhyZWNlaXZlcklkOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnR5cGluZ1RpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnR5cGluZ1RpbWVyKTtcclxuICAgICAgdGhpcy50eXBpbmdUaW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNlbmRUeXBpbmdJbmRpY2F0b3IocmVjZWl2ZXJJZCwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2VuZE1lc3NhZ2VIdHRwKHJlY2VpdmVySWQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxDaGF0TWVzc2FnZT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3NlbmQtbWVzc2FnZScsIHtcclxuICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcclxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgbWVzc2FnZURhdGE6IENoYXRNZXNzYWdlID0ge1xyXG4gICAgICAgIGlkOiByZXNwb25zZS5kYXRhLmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc2VuZGVyX2lkOiByZXNwb25zZS5kYXRhLnNlbmRlcl9pZC50b1N0cmluZygpLFxyXG4gICAgICAgIHJlY2VpdmVyX2lkOiByZXNwb25zZS5kYXRhLnJlY2VpdmVyX2lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc2VuZGVyX25hbWU6ICdUw7onLFxyXG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLmRhdGEubWVzc2FnZSxcclxuICAgICAgICB0aW1lc3RhbXA6IHJlc3BvbnNlLmRhdGEudGltZXN0YW1wLFxyXG4gICAgICAgIGlzX21pbmU6IHRydWVcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIE5vdGlmaWNhciBhIGxvcyBjYWxsYmFja3NcclxuICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sobWVzc2FnZURhdGEpKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBtZXNzYWdlRGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZXNzYWdlKGNhbGxiYWNrOiBNZXNzYWdlQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvblVzZXJTdGF0dXNDaGFuZ2UoY2FsbGJhY2s6IFVzZXJTdGF0dXNDYWxsYmFjayk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy51c2VyU3RhdHVzQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMudXNlclN0YXR1c0NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLnVzZXJTdGF0dXNDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9uQ29ubmVjdGlvblN0YXR1cyhjYWxsYmFjazogQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb25UeXBpbmcoY2FsbGJhY2s6IFR5cGluZ0NhbGxiYWNrKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLnR5cGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnR5cGluZ0NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICB0aGlzLnR5cGluZ0NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgb25VbnJlYWRNZXNzYWdlKGNhbGxiYWNrOiBVbnJlYWRNZXNzYWdlQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMudW5yZWFkTWVzc2FnZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnVucmVhZE1lc3NhZ2VDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy51bnJlYWRNZXNzYWdlQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbigpOiB2b2lkIHtcclxuICAgIGlmICgnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICBOb3RpZmljYXRpb24ucmVxdWVzdFBlcm1pc3Npb24oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldE1lc3NhZ2VzKHJlY2VpdmVySWQ6IHN0cmluZyk6IFByb21pc2U8Q2hhdE1lc3NhZ2VbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNhciBsYSBudWV2YSBydXRhIHF1ZSBtYW5lamEgVVVJRHNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvZ2V0LW1lc3NhZ2VzLXV1aWQvJHtyZWNlaXZlcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXNzYWdlcyB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VXNlcnMoKTogUHJvbWlzZTxVc2VyW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2dldC1jaGF0LWRvY3RvcnMnKTtcclxuICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgIHJldHVybiBkYXRhLmRvY3RvcnM/Lm1hcCgoZG9jdG9yOiBhbnkpID0+ICh7XHJcbiAgICAgICAgaWQ6IGRvY3Rvci5pZC50b1N0cmluZygpLFxyXG4gICAgICAgIHN1cGFiYXNlX2lkOiBkb2N0b3Iuc3VwYWJhc2VfaWQsXHJcbiAgICAgICAgbmFtZTogYCR7ZG9jdG9yLmZpcnN0TmFtZX0gJHtkb2N0b3IubGFzdE5hbWUxfWAsXHJcbiAgICAgICAgZW1haWw6IGRvY3Rvci5lbWFpbCxcclxuICAgICAgICBzcGVjaWFsdHk6IGRvY3Rvci5zcGVjaWFsaXR5LFxyXG4gICAgICAgIHN0YXR1czogJ29mZmxpbmUnIGFzIGNvbnN0XHJcbiAgICAgIH0pKSB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICcxJyxcclxuICAgICAgICAgIHN1cGFiYXNlX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLCAgLy8gR2VuZXJhciBVVUlEIHJlYWxcclxuICAgICAgICAgIG5hbWU6ICdEci4gSnVhbiBQw6lyZXonLFxyXG4gICAgICAgICAgZW1haWw6ICdqdWFuLnBlcmV6QGhvc3BpdGFsLmNvbScsXHJcbiAgICAgICAgICBzcGVjaWFsdHk6ICdDYXJkaW9sb2fDrWEnLFxyXG4gICAgICAgICAgc3RhdHVzOiAnb25saW5lJyBhcyBjb25zdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICcyJyxcclxuICAgICAgICAgIHN1cGFiYXNlX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLCAgLy8gR2VuZXJhciBVVUlEIHJlYWxcclxuICAgICAgICAgIG5hbWU6ICdEcmEuIE1hcsOtYSBHb256w6FsZXonLFxyXG4gICAgICAgICAgZW1haWw6ICdtYXJpYS5nb256YWxlekBob3NwaXRhbC5jb20nLFxyXG4gICAgICAgICAgc3BlY2lhbHR5OiAnTmV1cm9sb2fDrWEnLFxyXG4gICAgICAgICAgc3RhdHVzOiAnb2ZmbGluZScgYXMgY29uc3RcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiAnMycsXHJcbiAgICAgICAgICBzdXBhYmFzZV9pZDogY3J5cHRvLnJhbmRvbVVVSUQoKSwgIC8vIEdlbmVyYXIgVVVJRCByZWFsXHJcbiAgICAgICAgICBuYW1lOiAnRHIuIENhcmxvcyBMw7NwZXonLFxyXG4gICAgICAgICAgZW1haWw6ICdjYXJsb3MubG9wZXpAaG9zcGl0YWwuY29tJyxcclxuICAgICAgICAgIHNwZWNpYWx0eTogJ1BlZGlhdHLDrWEnLFxyXG4gICAgICAgICAgc3RhdHVzOiAnb2ZmbGluZScgYXMgY29uc3RcclxuICAgICAgICB9XHJcbiAgICAgIF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVbnJlYWRDb3VudHMoKTogUHJvbWlzZTx7IFt1c2VySWQ6IHN0cmluZ106IG51bWJlciB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9nZXQtdW5yZWFkLWNvdW50cycpO1xyXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgcmV0dXJuIGRhdGEudW5yZWFkX2NvdW50cyB8fCB7fTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjaGF0U2VydmljZSA9IG5ldyBDaGF0U2VydmljZSgpO1xyXG5leHBvcnQgdHlwZSB7IENoYXRNZXNzYWdlLCBVc2VyLCBDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2ssIFR5cGluZ0NhbGxiYWNrLCBVbnJlYWRNZXNzYWdlQ2FsbGJhY2sgfTtcclxuIl0sIm5hbWVzIjpbImlvIiwiYXBpIiwiQ2hhdFNlcnZpY2UiLCJjb25uZWN0IiwiY29ubmVjdFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNvY2tldCIsImNvbm5lY3RlZCIsImNvbnNvbGUiLCJsb2ciLCJpc0Nvbm5lY3RpbmciLCJiYXNlVXJsIiwid2l0aENyZWRlbnRpYWxzIiwidHJhbnNwb3J0cyIsInRpbWVvdXQiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJmb3JjZU5ldyIsImF1dG9Db25uZWN0IiwidXBncmFkZSIsInJlbWVtYmVyVXBncmFkZSIsIm9uIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJjb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2tzIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJzZXRUaW1lb3V0IiwiYXR0ZW1wdFJlY29ubmVjdCIsInJlYXNvbiIsInNob3dOb3RpZmljYXRpb24iLCJtZXNzYWdlQ2FsbGJhY2tzIiwiZGF0YSIsInVzZXJTdGF0dXNDYWxsYmFja3MiLCJ1c2VyX2lkIiwic3RhdHVzIiwidHlwaW5nQ2FsbGJhY2tzIiwiaXNfdHlwaW5nIiwidW5yZWFkTWVzc2FnZUNhbGxiYWNrcyIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwiZGVsYXkiLCJNYXRoIiwibWluIiwicG93Iiwid2luZG93IiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsImRvY3VtZW50IiwiaGlkZGVuIiwic2VuZGVyX25hbWUiLCJib2R5IiwiaWNvbiIsInRhZyIsImRpc2Nvbm5lY3QiLCJpc1NvY2tldENvbm5lY3RlZCIsInNlbmRNZXNzYWdlIiwicmVjZWl2ZXJJZCIsInNlbmRNZXNzYWdlSHR0cCIsImNhdGNoIiwiZW1pdCIsInJlY2VpdmVyX2lkIiwic2VuZFR5cGluZ0luZGljYXRvciIsImlzVHlwaW5nIiwic3RhcnRUeXBpbmciLCJ0eXBpbmdUaW1lciIsImNsZWFyVGltZW91dCIsInN0b3BUeXBpbmciLCJyZXNwb25zZSIsInBvc3QiLCJtZXNzYWdlRGF0YSIsImlkIiwidG9TdHJpbmciLCJzZW5kZXJfaWQiLCJ0aW1lc3RhbXAiLCJpc19taW5lIiwib25NZXNzYWdlIiwicHVzaCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIm9uVXNlclN0YXR1c0NoYW5nZSIsIm9uQ29ubmVjdGlvblN0YXR1cyIsIm9uVHlwaW5nIiwib25VbnJlYWRNZXNzYWdlIiwicmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsImdldE1lc3NhZ2VzIiwiZ2V0IiwibWVzc2FnZXMiLCJnZXRVc2VycyIsImRvY3RvcnMiLCJtYXAiLCJkb2N0b3IiLCJzdXBhYmFzZV9pZCIsIm5hbWUiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZTEiLCJlbWFpbCIsInNwZWNpYWx0eSIsInNwZWNpYWxpdHkiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiZ2V0VW5yZWFkQ291bnRzIiwidW5yZWFkX2NvdW50cyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiY2hhdFNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatRealTime.ts\n"));

/***/ })

});